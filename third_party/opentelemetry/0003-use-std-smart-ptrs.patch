diff --git a/api/include/opentelemetry/nostd/shared_ptr.h b/api/include/opentelemetry/nostd/shared_ptr.h
index e1eac61..b6ec053 100644
--- a/api/include/opentelemetry/nostd/shared_ptr.h
+++ b/api/include/opentelemetry/nostd/shared_ptr.h
@@ -2,189 +2,5 @@
 // SPDX-License-Identifier: Apache-2.0
 
 #pragma once
-#ifdef HAVE_CPP_STDLIB
-#  include "opentelemetry/std/shared_ptr.h"
-#else
-#  include <cstdlib>
-#  include <memory>
-#  include <utility>
-
-#  include "opentelemetry/version.h"
-
-OPENTELEMETRY_BEGIN_NAMESPACE
-namespace nostd
-{
-/**
- * Provide a type-erased version of std::shared_ptr that has ABI stability.
- */
-template <class T>
-class shared_ptr
-{
-public:
-  using element_type = T;
-  using pointer      = element_type *;
-
-private:
-  static constexpr size_t kMaxSize   = 32;
-  static constexpr size_t kAlignment = 8;
-
-  struct alignas(kAlignment) PlacementBuffer
-  {
-    char data[kMaxSize];
-  };
-
-  class shared_ptr_wrapper
-  {
-  public:
-    shared_ptr_wrapper() noexcept = default;
-
-    shared_ptr_wrapper(std::shared_ptr<T> &&ptr) noexcept : ptr_{std::move(ptr)} {}
-
-    virtual ~shared_ptr_wrapper() {}
-
-    virtual void CopyTo(PlacementBuffer &buffer) const noexcept
-    {
-      new (buffer.data) shared_ptr_wrapper{*this};
-    }
-
-    virtual void MoveTo(PlacementBuffer &buffer) noexcept
-    {
-      new (buffer.data) shared_ptr_wrapper{std::move(this->ptr_)};
-    }
-
-    template <class U,
-              typename std::enable_if<std::is_convertible<pointer, U *>::value>::type * = nullptr>
-    void MoveTo(typename shared_ptr<U>::PlacementBuffer &buffer) noexcept
-    {
-      new (buffer.data) shared_ptr_wrapper{std::move(this->ptr_)};
-    }
-
-    virtual pointer Get() const noexcept { return ptr_.get(); }
-
-    virtual void Reset() noexcept { ptr_.reset(); }
-
-  private:
-    std::shared_ptr<T> ptr_;
-  };
-
-  static_assert(sizeof(shared_ptr_wrapper) <= kMaxSize, "Placement buffer is too small");
-  static_assert(alignof(shared_ptr_wrapper) <= kAlignment, "Placement buffer not properly aligned");
-
-public:
-  shared_ptr() noexcept { new (buffer_.data) shared_ptr_wrapper{}; }
-
-  explicit shared_ptr(pointer ptr)
-  {
-    std::shared_ptr<T> ptr_(ptr);
-    new (buffer_.data) shared_ptr_wrapper{std::move(ptr_)};
-  }
-
-  shared_ptr(std::shared_ptr<T> ptr) noexcept
-  {
-    new (buffer_.data) shared_ptr_wrapper{std::move(ptr)};
-  }
-
-  shared_ptr(shared_ptr &&other) noexcept { other.wrapper().MoveTo(buffer_); }
-
-  template <class U,
-            typename std::enable_if<std::is_convertible<U *, pointer>::value>::type * = nullptr>
-  shared_ptr(shared_ptr<U> &&other) noexcept
-  {
-    other.wrapper().template MoveTo<T>(buffer_);
-  }
-
-  shared_ptr(const shared_ptr &other) noexcept { other.wrapper().CopyTo(buffer_); }
 
-  ~shared_ptr() { wrapper().~shared_ptr_wrapper(); }
-
-  shared_ptr &operator=(shared_ptr &&other) noexcept
-  {
-    wrapper().~shared_ptr_wrapper();
-    other.wrapper().MoveTo(buffer_);
-    return *this;
-  }
-
-  shared_ptr &operator=(std::nullptr_t) noexcept
-  {
-    wrapper().Reset();
-    return *this;
-  }
-
-  shared_ptr &operator=(const shared_ptr &other) noexcept
-  {
-    wrapper().~shared_ptr_wrapper();
-    other.wrapper().CopyTo(buffer_);
-    return *this;
-  }
-
-  element_type &operator*() const noexcept { return *wrapper().Get(); }
-
-  pointer operator->() const noexcept { return wrapper().Get(); }
-
-  operator bool() const noexcept { return wrapper().Get() != nullptr; }
-
-  pointer get() const noexcept { return wrapper().Get(); }
-
-  void swap(shared_ptr<T> &other) noexcept
-  {
-    shared_ptr<T> tmp{std::move(other)};
-
-    wrapper().MoveTo(other.buffer_);
-    tmp.wrapper().MoveTo(buffer_);
-  }
-
-  template <typename U>
-  friend class shared_ptr;
-
-private:
-  PlacementBuffer buffer_;
-
-  shared_ptr_wrapper &wrapper() noexcept
-  {
-    return *reinterpret_cast<shared_ptr_wrapper *>(buffer_.data);
-  }
-
-  const shared_ptr_wrapper &wrapper() const noexcept
-  {
-    return *reinterpret_cast<const shared_ptr_wrapper *>(buffer_.data);
-  }
-};
-
-template <class T1, class T2>
-bool operator!=(const shared_ptr<T1> &lhs, const shared_ptr<T2> &rhs) noexcept
-{
-  return lhs.get() != rhs.get();
-}
-
-template <class T1, class T2>
-bool operator==(const shared_ptr<T1> &lhs, const shared_ptr<T2> &rhs) noexcept
-{
-  return lhs.get() == rhs.get();
-}
-
-template <class T>
-inline bool operator==(const shared_ptr<T> &lhs, std::nullptr_t) noexcept
-{
-  return lhs.get() == nullptr;
-}
-
-template <class T>
-inline bool operator==(std::nullptr_t, const shared_ptr<T> &rhs) noexcept
-{
-  return nullptr == rhs.get();
-}
-
-template <class T>
-inline bool operator!=(const shared_ptr<T> &lhs, std::nullptr_t) noexcept
-{
-  return lhs.get() != nullptr;
-}
-
-template <class T>
-inline bool operator!=(std::nullptr_t, const shared_ptr<T> &rhs) noexcept
-{
-  return nullptr != rhs.get();
-}
-}  // namespace nostd
-OPENTELEMETRY_END_NAMESPACE
-#endif
+#  include "opentelemetry/std/shared_ptr.h"
diff --git a/api/include/opentelemetry/nostd/unique_ptr.h b/api/include/opentelemetry/nostd/unique_ptr.h
index a97111b..dba7cbe 100644
--- a/api/include/opentelemetry/nostd/unique_ptr.h
+++ b/api/include/opentelemetry/nostd/unique_ptr.h
@@ -3,173 +3,4 @@
 
 #pragma once
 
-#ifdef HAVE_CPP_STDLIB
 #  include "opentelemetry/std/unique_ptr.h"
-#else
-#  include <cstddef>
-#  include <memory>
-#  include <type_traits>
-#  include <utility>
-
-#  include "opentelemetry/version.h"
-
-OPENTELEMETRY_BEGIN_NAMESPACE
-namespace nostd
-{
-namespace detail
-{
-template <class T>
-struct unique_ptr_element_type
-{
-  using type = T;
-};
-
-template <class T>
-struct unique_ptr_element_type<T[]>
-{
-  using type = T;
-};
-}  // namespace detail
-
-/**
- * Provide a simplified port of std::unique_ptr that has ABI stability.
- *
- * Note: This implementation doesn't allow for a custom deleter.
- */
-template <class T>
-class unique_ptr
-{
-public:
-  using element_type = typename detail::unique_ptr_element_type<T>::type;
-  using pointer      = element_type *;
-
-  unique_ptr() noexcept : ptr_{nullptr} {}
-
-  unique_ptr(std::nullptr_t) noexcept : ptr_{nullptr} {}
-
-  explicit unique_ptr(pointer ptr) noexcept : ptr_{ptr} {}
-
-  unique_ptr(unique_ptr &&other) noexcept : ptr_{other.release()} {}
-
-  template <class U,
-            typename std::enable_if<std::is_convertible<U *, pointer>::value>::type * = nullptr>
-  unique_ptr(unique_ptr<U> &&other) noexcept : ptr_{other.release()}
-  {}
-
-  template <class U,
-            typename std::enable_if<std::is_convertible<U *, pointer>::value>::type * = nullptr>
-  unique_ptr(std::unique_ptr<U> &&other) noexcept : ptr_{other.release()}
-  {}
-
-  ~unique_ptr() { reset(); }
-
-  unique_ptr &operator=(unique_ptr &&other) noexcept
-  {
-    reset(other.release());
-    return *this;
-  }
-
-  unique_ptr &operator=(std::nullptr_t) noexcept
-  {
-    reset();
-    return *this;
-  }
-
-  template <class U,
-            typename std::enable_if<std::is_convertible<U *, pointer>::value>::type * = nullptr>
-  unique_ptr &operator=(unique_ptr<U> &&other) noexcept
-  {
-    reset(other.release());
-    return *this;
-  }
-
-  template <class U,
-            typename std::enable_if<std::is_convertible<U *, pointer>::value>::type * = nullptr>
-  unique_ptr &operator=(std::unique_ptr<U> &&other) noexcept
-  {
-    reset(other.release());
-    return *this;
-  }
-
-  operator std::unique_ptr<T>() &&noexcept { return std::unique_ptr<T>{release()}; }
-
-  operator bool() const noexcept { return ptr_ != nullptr; }
-
-  element_type &operator*() const noexcept { return *ptr_; }
-
-  pointer operator->() const noexcept { return get(); }
-
-  pointer get() const noexcept { return ptr_; }
-
-  void reset(pointer ptr = nullptr) noexcept
-  {
-    if (ptr_ != nullptr)
-    {
-      this->delete_ptr();
-    }
-    ptr_ = ptr;
-  }
-
-  pointer release() noexcept
-  {
-    auto result = ptr_;
-    ptr_        = nullptr;
-    return result;
-  }
-
-  void swap(unique_ptr &other) noexcept { std::swap(ptr_, other.ptr_); }
-
-private:
-  pointer ptr_;
-
-  void delete_ptr() noexcept
-  {
-    if (std::is_array<T>::value)
-    {
-      delete[] ptr_;
-    }
-    else
-    {
-      delete ptr_;
-    }
-  }
-};
-
-template <class T1, class T2>
-bool operator==(const unique_ptr<T1> &lhs, const unique_ptr<T2> &rhs) noexcept
-{
-  return lhs.get() == rhs.get();
-}
-
-template <class T>
-bool operator==(const unique_ptr<T> &lhs, std::nullptr_t) noexcept
-{
-  return lhs.get() == nullptr;
-}
-
-template <class T>
-bool operator==(std::nullptr_t, const unique_ptr<T> &rhs) noexcept
-{
-  return nullptr == rhs.get();
-}
-
-template <class T1, class T2>
-bool operator!=(const unique_ptr<T1> &lhs, const unique_ptr<T2> &rhs) noexcept
-{
-  return lhs.get() != rhs.get();
-}
-
-template <class T>
-bool operator!=(const unique_ptr<T> &lhs, std::nullptr_t) noexcept
-{
-  return lhs.get() != nullptr;
-}
-
-template <class T>
-bool operator!=(std::nullptr_t, const unique_ptr<T> &rhs) noexcept
-{
-  return nullptr != rhs.get();
-}
-}  // namespace nostd
-OPENTELEMETRY_END_NAMESPACE
-#endif
