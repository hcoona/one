diff --git a/gtl/path.cc b/gtl/path.cc
index fdc8c86..82ea990 100644
--- a/gtl/path.cc
+++ b/gtl/path.cc
@@ -20,27 +20,27 @@ limitations under the License.
 #include <stdlib.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#if defined(OS_WIN)
-#include <windows.h>
-#else
-#include <unistd.h>
-#endif

 #include <vector>

+#include "third_party/absl/strings/str_cat.h"
+#include "third_party/absl/synchronization/mutex.h"
 #include "third_party/glog/logging.h"
-#include "gtl/mutex.h"
 #include "gtl/scanner.h"
-#include "gtl/strcat.h"

+#if defined(OS_WIN)
+#include <windows.h>
+#else
+#include <unistd.h>
+#endif

-namespace io {
+namespace gtl {
 namespace internal {
 namespace {

 const char kPathSep[] = "/";

-bool FixBazelEnvPath(const char* path, string* out) {
+bool FixBazelEnvPath(const char* path, std::string* out) {
   if (path == nullptr) return false;
   if (out == nullptr) return true;

@@ -50,9 +50,9 @@ bool FixBazelEnvPath(const char* path, string* out) {
   // On Windows, paths generated by Bazel are always use `/` as the path
   // separator. This prevents normal path management. In the event there are no
   // `\` in the path, we convert all `/` to `\`.
-  if (out->find('\\') != string::npos) return path;
+  if (out->find('\\') != std::string::npos) return path;

-  for (size_t pos = out->find('/'); pos != string::npos;
+  for (size_t pos = out->find('/'); pos != std::string::npos;
        pos = out->find('/', pos + 1)) {
     (*out)[pos] = kPathSep[0];
   }
@@ -63,23 +63,23 @@ bool FixBazelEnvPath(const char* path, string* out) {

 }  // namespace

-string JoinPathImpl(std::initializer_list<absl::string_view> paths) {
-  string result;
+std::string JoinPathImpl(std::initializer_list<absl::string_view> paths) {
+  std::string result;

   for (absl::string_view path : paths) {
     if (path.empty()) continue;

     if (result.empty()) {
-      result = string(path);
+      result = std::string(path);
       continue;
     }

     if (IsAbsolutePath(path)) path = path.substr(1);

     if (result[result.size() - 1] == kPathSep[0]) {
-      strings::StrAppend(&result, path);
+      absl::StrAppend(&result, path);
     } else {
-      strings::StrAppend(&result, kPathSep, path);
+      absl::StrAppend(&result, kPathSep, path);
     }
   }

@@ -146,10 +146,10 @@ absl::string_view Extension(absl::string_view path) {
   return internal::SplitBasename(path).second;
 }

-string CleanPath(absl::string_view unclean_path) {
-  string path(unclean_path);
+std::string CleanPath(absl::string_view unclean_path) {
+  std::string path(unclean_path);
   const char* src = path.c_str();
-  string::iterator dst = path.begin();
+  std::string::iterator dst = path.begin();

   // Check for absolute path and determine initial backtrack limit.
   const bool is_absolute_path = *src == '/';
@@ -157,7 +157,7 @@ string CleanPath(absl::string_view unclean_path) {
     *dst++ = *src++;
     while (*src == '/') ++src;
   }
-  string::const_iterator backtrack_limit = dst;
+  std::string::const_iterator backtrack_limit = dst;

   // Process all parts
   while (*src) {
@@ -213,7 +213,7 @@ string CleanPath(absl::string_view unclean_path) {
   }

   // Calculate and check the length of the cleaned path.
-  string::difference_type path_length = dst - path.begin();
+  std::string::difference_type path_length = dst - path.begin();
   if (path_length != 0) {
     // Remove trailing '/' except if it is root path ("/" ==> path_length := 1)
     if (path_length > 1 && path[path_length - 1] == '/') {
@@ -233,13 +233,13 @@ void ParseURI(absl::string_view remaining, absl::string_view* scheme, absl::stri
   // Make sure scheme matches [a-zA-Z][0-9a-zA-Z.]*
   // TODO(keveman): Allow "+" and "-" in the scheme.
   // Keep URI pattern in tensorboard/backend/server.py updated accordingly
-  if (!strings::Scanner(remaining)
-           .One(strings::Scanner::LETTER)
-           .Many(strings::Scanner::LETTER_DIGIT_DOT)
+  if (!gtl::Scanner(remaining)
+           .One(gtl::Scanner::LETTER)
+           .Many(gtl::Scanner::LETTER_DIGIT_DOT)
            .StopCapture()
            .OneLiteral("://")
            .GetResult(&remaining, scheme)) {
-    // If there's no scheme, assume the entire string is a path.
+    // If there's no scheme, assume the entire std::string is a path.
     *scheme = absl::string_view(remaining.begin(), 0);
     *host = absl::string_view(remaining.begin(), 0);
     *path = remaining;
@@ -247,7 +247,7 @@ void ParseURI(absl::string_view remaining, absl::string_view* scheme, absl::stri
   }

   // 1. Parse host
-  if (!strings::Scanner(remaining).ScanUntil('/').GetResult(&remaining, host)) {
+  if (!gtl::Scanner(remaining).ScanUntil('/').GetResult(&remaining, host)) {
     // No path, so the rest of the URI is the host.
     *host = remaining;
     *path = absl::string_view(remaining.end(), 0);
@@ -258,22 +258,22 @@ void ParseURI(absl::string_view remaining, absl::string_view* scheme, absl::stri
   *path = remaining;
 }

-string CreateURI(absl::string_view scheme, absl::string_view host, absl::string_view path) {
+std::string CreateURI(absl::string_view scheme, absl::string_view host, absl::string_view path) {
   if (scheme.empty()) {
-    return string(path);
+    return std::string(path);
   }
-  return strings::StrCat(scheme, "://", host, path);
+  return absl::StrCat(scheme, "://", host, path);
 }

 // Returns a unique number every time it is called.
-int64 UniqueId() {
-  static mutex mu(LINKER_INITIALIZED);
-  static int64 id = 0;
-  mutex_lock l(mu);
+int64_t UniqueId() {
+  static absl::Mutex mu;
+  static int64_t id = 0;
+  absl::MutexLock l(&mu);
   return ++id;
 }

-string GetTempFilename(const string& extension) {
+std::string GetTempFilename(const std::string& extension) {
 #if defined(__ANDROID__)
   LOG(FATAL) << "GetTempFilename is not implemented in this platform.";
 #elif defined(OS_WIN)
@@ -290,7 +290,7 @@ string GetTempFilename(const string& extension) {
     LOG(FATAL) << "Cannot get a temporary file in: " << temp_dir;
   }

-  string full_tmp_file_name(temp_file_name);
+  std::string full_tmp_file_name(temp_file_name);
   full_tmp_file_name.append(extension);
   return full_tmp_file_name;
 #else
@@ -304,17 +304,17 @@ string GetTempFilename(const string& extension) {
       // UniqueId is added here because mkstemps is not as thread safe as it
       // looks. https://github.com/tensorflow/tensorflow/issues/5804 shows
       // the problem.
-      string tmp_filepath;
+      std::string tmp_filepath;
       int fd;
       if (extension.length()) {
-        tmp_filepath = io::JoinPath(
-            dir, strings::StrCat("tmp_file_tensorflow_", UniqueId(), "_XXXXXX.",
+        tmp_filepath = JoinPath(
+            dir, absl::StrCat("tmp_file_tensorflow_", UniqueId(), "_XXXXXX.",
                                  extension));
         fd = mkstemps(&tmp_filepath[0], extension.length() + 1);
       } else {
-        tmp_filepath = io::JoinPath(
+        tmp_filepath = JoinPath(
             dir,
-            strings::StrCat("tmp_file_tensorflow_", UniqueId(), "_XXXXXX"));
+            absl::StrCat("tmp_file_tensorflow_", UniqueId(), "_XXXXXX"));
         fd = mkstemp(&tmp_filepath[0]);
       }
       if (fd < 0) {
@@ -329,9 +329,9 @@ string GetTempFilename(const string& extension) {
 #endif
 }

-bool GetTestUndeclaredOutputsDir(string* dir) {
+bool GetTestUndeclaredOutputsDir(std::string* dir) {
   return internal::FixBazelEnvPath(getenv("TEST_UNDECLARED_OUTPUTS_DIR"), dir);
 }

-}  // namespace io
+}  // namespace gtl

diff --git a/gtl/path.h b/gtl/path.h
index e64db62..dcf1655 100644
--- a/gtl/path.h
+++ b/gtl/path.h
@@ -16,13 +16,14 @@ limitations under the License.
 #ifndef GTL_PATH_H_
 #define GTL_PATH_H_

-#include "gtl/stringpiece.h"
-#include "gtl/types.h"
+#include <initializer_list>
+#include <string>

+#include "third_party/absl/strings/string_view.h"

-namespace io {
+namespace gtl {
 namespace internal {
-string JoinPathImpl(std::initializer_list<tensorflow::absl::string_view> paths);
+std::string JoinPathImpl(std::initializer_list<absl::string_view> paths);
 }

 // Utility routines for processing filenames
@@ -39,30 +40,30 @@ string JoinPathImpl(std::initializer_list<tensorflow::absl::string_view> paths);
 //  '/foo', '/bar'             | /foo/bar
 //
 // Usage:
-// string path = io::JoinPath("/mydir", filename);
-// string path = io::JoinPath(FLAGS_test_srcdir, filename);
-// string path = io::JoinPath("/full", "path", "to", "filename");
+// std::string path = io::JoinPath("/mydir", filename);
+// std::string path = io::JoinPath(FLAGS_test_srcdir, filename);
+// std::string path = io::JoinPath("/full", "path", "to", "filename");
 template <typename... T>
-string JoinPath(const T&... args) {
+std::string JoinPath(const T&... args) {
   return internal::JoinPathImpl({args...});
 }
 #endif /* SWIG */

 // Return true if path is absolute.
-bool IsAbsolutePath(tensorflow::absl::string_view path);
+bool IsAbsolutePath(absl::string_view path);

 // Returns the part of the path before the final "/".  If there is a single
 // leading "/" in the path, the result will be the leading "/".  If there is
 // no "/" in the path, the result is the empty prefix of the input.
-tensorflow::absl::string_view Dirname(tensorflow::absl::string_view path);
+absl::string_view Dirname(absl::string_view path);

 // Returns the part of the path after the final "/".  If there is no
 // "/" in the path, the result is the same as the input.
-tensorflow::absl::string_view Basename(tensorflow::absl::string_view path);
+absl::string_view Basename(absl::string_view path);

 // Returns the part of the basename of path after the final ".".  If
 // there is no "." in the basename, the result is empty.
-tensorflow::absl::string_view Extension(tensorflow::absl::string_view path);
+absl::string_view Extension(absl::string_view path);

 // Collapse duplicate "/"s, resolve ".." and "." path elements, remove
 // trailing "/".
@@ -70,8 +71,8 @@ tensorflow::absl::string_view Extension(tensorflow::absl::string_view path);
 // NOTE: This respects relative vs. absolute paths, but does not
 // invoke any system calls (getcwd(2)) in order to resolve relative
 // paths with respect to the actual working directory.  That is, this is purely
-// string manipulation, completely independent of process state.
-string CleanPath(tensorflow::absl::string_view path);
+// std::string manipulation, completely independent of process state.
+std::string CleanPath(absl::string_view path);

 // Populates the scheme, host, and path from a URI. scheme, host, and path are
 // guaranteed by this function to point into the contents of uri, even if
@@ -79,18 +80,18 @@ string CleanPath(tensorflow::absl::string_view path);
 //
 // Corner cases:
 // - If the URI is invalid, scheme and host are set to empty strings and the
-//   passed string is assumed to be a path
+//   passed std::string is assumed to be a path
 // - If the URI omits the path (e.g. file://host), then the path is left empty.
-void ParseURI(tensorflow::absl::string_view uri, tensorflow::absl::string_view* scheme,
-              tensorflow::absl::string_view* host, tensorflow::absl::string_view* path);
+void ParseURI(absl::string_view uri, absl::string_view* scheme,
+              absl::string_view* host, absl::string_view* path);

 // Creates a URI from a scheme, host, and path. If the scheme is empty, we just
 // return the path.
-string CreateURI(tensorflow::absl::string_view scheme, tensorflow::absl::string_view host,
-                 tensorflow::absl::string_view path);
+std::string CreateURI(absl::string_view scheme, absl::string_view host,
+                 absl::string_view path);

 // Creates a temporary file name with an extension.
-string GetTempFilename(const string& extension);
+std::string GetTempFilename(const std::string& extension);

 // Reads the TEST_UNDECLARED_OUTPUTS_DIR environment variable, and if set
 // assigns `dir` to the value. `dir` is not modified if the environment variable
@@ -99,9 +100,9 @@ string GetTempFilename(const string& extension);
 //
 // Note: This function obviates the need to deal with Bazel's odd path decisions
 // on Windows, and should be preferred over a simple `getenv`.
-bool GetTestUndeclaredOutputsDir(string* dir);
+bool GetTestUndeclaredOutputsDir(std::string* dir);

-}  // namespace io
+}  // namespace gtl


 #endif  // GTL_PATH_H_
diff --git a/gtl/path_test.cc b/gtl/path_test.cc
index b6b8a5e..596ebd4 100644
--- a/gtl/path_test.cc
+++ b/gtl/path_test.cc
@@ -13,11 +13,11 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/

-#include "tensorflow/core/lib/io/path.h"
-#include "gtest/gtest.h"
+#include "gtl/path.h"

+#include "gtest/gtest.h"

-namespace io {
+namespace gtl {

 TEST(PathTest, JoinPath) {
   EXPECT_EQ("/foo/bar", JoinPath("/foo", "bar"));
@@ -141,5 +141,4 @@ TEST(PathTest, CreateParseURI) {
 }
 #undef EXPECT_PARSE_URI

-}  // namespace io
-
+}  // namespace gtl
