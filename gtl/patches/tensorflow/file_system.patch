diff --git a/gtl/file_statistics.h b/gtl/file_statistics.h
index bd9ad37..4ab2360 100644
--- a/gtl/file_statistics.h
+++ b/gtl/file_statistics.h
@@ -16,24 +16,22 @@ limitations under the License.
 #ifndef GTL_FILE_STATISTICS_H_
 #define GTL_FILE_STATISTICS_H_

-#include "gtl/types.h"
-
-
+namespace gtl {

 struct FileStatistics {
   // The length of the file or -1 if finding file length is not supported.
-  int64 length = -1;
+  int64_t length = -1;
   // The last modified time in nanoseconds.
-  int64 mtime_nsec = 0;
+  int64_t mtime_nsec = 0;
   // True if the file is a directory, otherwise false.
   bool is_directory = false;

   FileStatistics() {}
-  FileStatistics(int64 length, int64 mtime_nsec, bool is_directory)
+  FileStatistics(int64_t length, int64_t mtime_nsec, bool is_directory)
       : length(length), mtime_nsec(mtime_nsec), is_directory(is_directory) {}
   ~FileStatistics() {}
 };

-
+}  // namespace gtl

 #endif  // GTL_FILE_STATISTICS_H_
diff --git a/gtl/file_system.cc b/gtl/file_system.cc
index a7d4ce9..052a3a2 100644
--- a/gtl/file_system.cc
+++ b/gtl/file_system.cc
@@ -19,43 +19,44 @@ limitations under the License.

 #include <algorithm>
 #include <deque>
+#include <memory>
 #include <string>
 #include <utility>
 #include <vector>

-#if defined(OS_POSIX) || defined(IS_MOBILE_PLATFORM)
-#include <fnmatch.h>
-#else
-#include "gtl/regexp.h"
-#endif  // defined(OS_POSIX) || defined(IS_MOBILE_PLATFORM)
-
-#include "gtl/env.h"
-#include "gtl/errors.h"
-#include "gtl/platform.h"
+#include "third_party/absl/strings/str_cat.h"
+#include "third_party/absl/strings/str_replace.h"
+#include "third_party/glog/logging.h"
+#include "config/config.h"
+#include "gtl/path.h"
 #include "gtl/scanner.h"
-#include "gtl/str_util.h"
-#include "gtl/strcat.h"

+#if defined(OS_POSIX)
+#include <fnmatch.h>
+#else
+#include "re2/re2.h"
+#endif  // defined(OS_POSIX)

+namespace gtl {

-bool FileSystem::Match(const string& filename, const string& pattern) {
-#if defined(OS_POSIX) || defined(IS_MOBILE_PLATFORM)
+bool FileSystem::Match(const std::string& filename, const std::string& pattern) {
+#if defined(OS_POSIX)
   // We avoid relying on RE2 on mobile platforms, because it incurs a
   // significant binary size increase.
   // For POSIX platforms, there is no need to depend on RE2 if `fnmatch` can be
   // used safely.
   return fnmatch(pattern.c_str(), filename.c_str(), FNM_PATHNAME) == 0;
 #else
-  string regexp(pattern);
-  regexp = str_util::StringReplace(regexp, "*", "[^/]*", true);
-  regexp = str_util::StringReplace(regexp, "?", ".", true);
-  regexp = str_util::StringReplace(regexp, "(", "\\(", true);
-  regexp = str_util::StringReplace(regexp, ")", "\\)", true);
+  std::string regexp(pattern);
+  regexp = absl::StrReplaceAll(regexp, "*", "[^/]*");
+  regexp = absl::StrReplaceAll(regexp, "?", ".");
+  regexp = absl::StrReplaceAll(regexp, "(", "\\(");
+  regexp = absl::StrReplaceAll(regexp, ")", "\\)");
   return RE2::FullMatch(filename, regexp);
-#endif  // defined(OS_POSIX) || defined(IS_MOBILE_PLATFORM)
+#endif
 }

-string FileSystem::TranslateName(const string& name) const {
+std::string FileSystem::TranslateName(const std::string& name) const {
   // If the name is empty, CleanPath returns "." which is incorrect and
   // we should return the empty path instead.
   if (name.empty()) return name;
@@ -70,29 +71,37 @@ string FileSystem::TranslateName(const string& name) const {
   return this->CleanPath(path);
 }

-Status FileSystem::IsDirectory(const string& name) {
+absl::Status FileSystem::IsDirectory(const std::string& name) {
   // Check if path exists.
-  TF_RETURN_IF_ERROR(FileExists(name));
+  absl::Status s = FileExists(name);
+  if (!s.ok()) {
+    return s;
+  }
+
   FileStatistics stat;
-  TF_RETURN_IF_ERROR(Stat(name, &stat));
+  s = Stat(name, &stat);
+  if (!s.ok()) {
+    return s;
+  }
+
   if (stat.is_directory) {
-    return Status::OK();
+    return absl::OkStatus();
   }
-  return Status(tensorflow::error::FAILED_PRECONDITION, "Not a directory");
+  return absl::FailedPreconditionError("Not a directory");
 }

-Status FileSystem::HasAtomicMove(const string& path, bool* has_atomic_move) {
+absl::Status FileSystem::HasAtomicMove(const std::string& path, bool* has_atomic_move) {
   *has_atomic_move = true;
-  return Status::OK();
+  return absl::OkStatus();
 }

 void FileSystem::FlushCaches() {}

-bool FileSystem::FilesExist(const std::vector<string>& files,
-                            std::vector<Status>* status) {
+bool FileSystem::FilesExist(const std::vector<std::string>& files,
+                            std::vector<absl::Status>* status) {
   bool result = true;
   for (const auto& file : files) {
-    Status s = FileExists(file);
+    absl::Status s = FileExists(file);
     result &= s.ok();
     if (status != nullptr) {
       status->push_back(s);
@@ -104,16 +113,16 @@ bool FileSystem::FilesExist(const std::vector<string>& files,
   return result;
 }

-Status FileSystem::DeleteRecursively(const string& dirname,
-                                     int64* undeleted_files,
-                                     int64* undeleted_dirs) {
+absl::Status FileSystem::DeleteRecursively(const std::string& dirname,
+                                           int64_t* undeleted_files,
+                                           int64_t* undeleted_dirs) {
   CHECK_NOTNULL(undeleted_files);
   CHECK_NOTNULL(undeleted_dirs);

   *undeleted_files = 0;
   *undeleted_dirs = 0;
   // Make sure that dirname exists;
-  Status exists_status = FileExists(dirname);
+  absl::Status exists_status = FileExists(dirname);
   if (!exists_status.ok()) {
     (*undeleted_dirs)++;
     return exists_status;
@@ -121,39 +130,39 @@ Status FileSystem::DeleteRecursively(const string& dirname,

   // If given path to a single file, we should just delete it.
   if (!IsDirectory(dirname).ok()) {
-    Status delete_root_status = DeleteFile(dirname);
+    absl::Status delete_root_status = DeleteFile(dirname);
     if (!delete_root_status.ok()) (*undeleted_files)++;
     return delete_root_status;
   }

-  std::deque<string> dir_q;      // Queue for the BFS
-  std::vector<string> dir_list;  // List of all dirs discovered
+  std::deque<std::string> dir_q;      // Queue for the BFS
+  std::vector<std::string> dir_list;  // List of all dirs discovered
   dir_q.push_back(dirname);
-  Status ret;  // Status to be returned.
+  absl::Status ret;  // absl::Status to be returned.
   // Do a BFS on the directory to discover all the sub-directories. Remove all
   // children that are files along the way. Then cleanup and remove the
   // directories in reverse order.;
   while (!dir_q.empty()) {
-    string dir = dir_q.front();
+    std::string dir = dir_q.front();
     dir_q.pop_front();
     dir_list.push_back(dir);
-    std::vector<string> children;
+    std::vector<std::string> children;
     // GetChildren might fail if we don't have appropriate permissions.
-    Status s = GetChildren(dir, &children);
+    absl::Status s = GetChildren(dir, &children);
     ret.Update(s);
     if (!s.ok()) {
       (*undeleted_dirs)++;
       continue;
     }
-    for (const string& child : children) {
-      const string child_path = this->JoinPath(dir, child);
+    for (const std::string& child : children) {
+      const std::string child_path = this->JoinPath(dir, child);
       // If the child is a directory add it to the queue, otherwise delete it.
       if (IsDirectory(child_path).ok()) {
         dir_q.push_back(child_path);
       } else {
         // Delete file might fail because of permissions issues or might be
         // unimplemented.
-        Status del_status = DeleteFile(child_path);
+        absl::Status del_status = DeleteFile(child_path);
         ret.Update(del_status);
         if (!del_status.ok()) {
           (*undeleted_files)++;
@@ -164,10 +173,10 @@ Status FileSystem::DeleteRecursively(const string& dirname,
   // Now reverse the list of directories and delete them. The BFS ensures that
   // we can delete the directories in this order.
   std::reverse(dir_list.begin(), dir_list.end());
-  for (const string& dir : dir_list) {
+  for (const std::string& dir : dir_list) {
     // Delete dir might fail because of permissions issues or might be
     // unimplemented.
-    Status s = DeleteDir(dir);
+    absl::Status s = DeleteDir(dir);
     ret.Update(s);
     if (!s.ok()) {
       (*undeleted_dirs)++;
@@ -176,31 +185,31 @@ Status FileSystem::DeleteRecursively(const string& dirname,
   return ret;
 }

-Status FileSystem::RecursivelyCreateDir(const string& dirname) {
+absl::Status FileSystem::RecursivelyCreateDir(const std::string& dirname) {
   absl::string_view scheme, host, remaining_dir;
   this->ParseURI(dirname, &scheme, &host, &remaining_dir);
   std::vector<absl::string_view> sub_dirs;
   while (!remaining_dir.empty()) {
     std::string current_entry = this->CreateURI(scheme, host, remaining_dir);
-    Status exists_status = FileExists(current_entry);
+    absl::Status exists_status = FileExists(current_entry);
     if (exists_status.ok()) {
       // FileExists cannot differentiate between existence of a file or a
       // directory, hence we need an additional test as we must not assume that
       // a path to a file is a path to a parent directory.
-      Status directory_status = IsDirectory(current_entry);
+      absl::Status directory_status = IsDirectory(current_entry);
       if (directory_status.ok()) {
         break;  // We need to start creating directories from here.
-      } else if (directory_status.code() == tensorflow::error::UNIMPLEMENTED) {
+      } else if (absl::IsUnimplemented(directory_status)) {
         return directory_status;
       } else {
-        return errors::FailedPrecondition(remaining_dir, " is not a directory");
+        return absl::FailedPreconditionError(absl::StrCat(remaining_dir, " is not a directory"));
       }
     }
-    if (exists_status.code() != error::Code::NOT_FOUND) {
+    if (!absl::IsNotFound(exists_status)) {
       return exists_status;
     }
     // Basename returns "" for / ending dirs.
-    if (!str_util::EndsWith(remaining_dir, "/")) {
+    if (!absl::EndsWith(remaining_dir, "/")) {
       sub_dirs.push_back(this->Basename(remaining_dir));
     }
     remaining_dir = this->Dirname(remaining_dir);
@@ -210,45 +219,45 @@ Status FileSystem::RecursivelyCreateDir(const string& dirname) {
   std::reverse(sub_dirs.begin(), sub_dirs.end());

   // Now create the directories.
-  string built_path(remaining_dir);
+  std::string built_path(remaining_dir);
   for (const absl::string_view sub_dir : sub_dirs) {
     built_path = this->JoinPath(built_path, sub_dir);
-    Status status = CreateDir(this->CreateURI(scheme, host, built_path));
-    if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {
+    absl::Status status = CreateDir(this->CreateURI(scheme, host, built_path));
+    if (!status.ok() && !absl::IsAlreadyExists(status)) {
       return status;
     }
   }
-  return Status::OK();
+  return absl::OkStatus();
 }

-Status FileSystem::CopyFile(const string& src, const string& target) {
+absl::Status FileSystem::CopyFile(const std::string& src, const std::string& target) {
   return FileSystemCopyFile(this, src, this, target);
 }

 char FileSystem::Separator() const { return '/'; }

-string FileSystem::JoinPathImpl(std::initializer_list<absl::string_view> paths) {
-  string result;
+std::string FileSystem::JoinPathImpl(std::initializer_list<absl::string_view> paths) {
+  std::string result;

   for (absl::string_view path : paths) {
     if (path.empty()) continue;

     if (result.empty()) {
-      result = string(path);
+      result = std::string(path);
       continue;
     }

     if (result[result.size() - 1] == '/') {
       if (this->IsAbsolutePath(path)) {
-        strings::StrAppend(&result, path.substr(1));
+        absl::StrAppend(&result, path.substr(1));
       } else {
-        strings::StrAppend(&result, path);
+        absl::StrAppend(&result, path);
       }
     } else {
       if (this->IsAbsolutePath(path)) {
-        strings::StrAppend(&result, path);
+        absl::StrAppend(&result, path);
       } else {
-        strings::StrAppend(&result, "/", path);
+        absl::StrAppend(&result, "/", path);
       }
     }
   }
@@ -267,11 +276,11 @@ std::pair<absl::string_view, absl::string_view> FileSystem::SplitPath(
   // also check for '/'
 #ifdef OS_WIN
   size_t pos2 = path.rfind('/');
-  // Pick the max value that is not string::npos.
-  if (pos == string::npos) {
+  // Pick the max value that is not std::string::npos.
+  if (pos == std::string::npos) {
     pos = pos2;
   } else {
-    if (pos2 != string::npos) {
+    if (pos2 != std::string::npos) {
       pos = pos > pos2 ? pos : pos2;
     }
   }
@@ -316,10 +325,10 @@ absl::string_view FileSystem::Extension(absl::string_view path) const {
   }
 }

-string FileSystem::CleanPath(absl::string_view unclean_path) const {
-  string path(unclean_path);
+std::string FileSystem::CleanPath(absl::string_view unclean_path) const {
+  std::string path(unclean_path);
   const char* src = path.c_str();
-  string::iterator dst = path.begin();
+  std::string::iterator dst = path.begin();

   // Check for absolute path and determine initial backtrack limit.
   const bool is_absolute_path = *src == '/';
@@ -327,7 +336,7 @@ string FileSystem::CleanPath(absl::string_view unclean_path) const {
     *dst++ = *src++;
     while (*src == '/') ++src;
   }
-  string::const_iterator backtrack_limit = dst;
+  std::string::const_iterator backtrack_limit = dst;

   // Process all parts
   while (*src) {
@@ -383,7 +392,7 @@ string FileSystem::CleanPath(absl::string_view unclean_path) const {
   }

   // Calculate and check the length of the cleaned path.
-  string::difference_type path_length = dst - path.begin();
+  std::string::difference_type path_length = dst - path.begin();
   if (path_length != 0) {
     // Remove trailing '/' except if it is root path ("/" ==> path_length := 1)
     if (path_length > 1 && path[path_length - 1] == '/') {
@@ -403,13 +412,13 @@ void FileSystem::ParseURI(absl::string_view remaining, absl::string_view* scheme
   // Make sure scheme matches [a-zA-Z][0-9a-zA-Z.]*
   // TODO(keveman): Allow "+" and "-" in the scheme.
   // Keep URI pattern in tensorboard/backend/server.py updated accordingly
-  if (!strings::Scanner(remaining)
-           .One(strings::Scanner::LETTER)
-           .Many(strings::Scanner::LETTER_DIGIT_DOT)
+  if (!gtl::Scanner(remaining)
+           .One(gtl::Scanner::LETTER)
+           .Many(gtl::Scanner::LETTER_DIGIT_DOT)
            .StopCapture()
            .OneLiteral("://")
            .GetResult(&remaining, scheme)) {
-    // If there's no scheme, assume the entire string is a path.
+    // If there's no scheme, assume the entire std::string is a path.
     *scheme = absl::string_view(remaining.begin(), 0);
     *host = absl::string_view(remaining.begin(), 0);
     *path = remaining;
@@ -417,7 +426,7 @@ void FileSystem::ParseURI(absl::string_view remaining, absl::string_view* scheme
   }

   // 1. Parse host
-  if (!strings::Scanner(remaining).ScanUntil('/').GetResult(&remaining, host)) {
+  if (!gtl::Scanner(remaining).ScanUntil('/').GetResult(&remaining, host)) {
     // No path, so the rest of the URI is the host.
     *host = remaining;
     *path = absl::string_view(remaining.end(), 0);
@@ -428,12 +437,58 @@ void FileSystem::ParseURI(absl::string_view remaining, absl::string_view* scheme
   *path = remaining;
 }

-string FileSystem::CreateURI(absl::string_view scheme, absl::string_view host,
+std::string FileSystem::CreateURI(absl::string_view scheme, absl::string_view host,
                              absl::string_view path) const {
   if (scheme.empty()) {
-    return string(path);
+    return std::string(path);
   }
-  return strings::StrCat(scheme, "://", host, path);
+  return absl::StrCat(scheme, "://", host, path);
 }

+// Copied from
+// https://github.com/tensorflow/tensorflow/blob/v2.2.0/tensorflow/core/platform/env.
+
+// 128KB copy buffer
+constexpr size_t kCopyFileBufferSize = 128 * 1024;
+
+absl::Status FileSystemCopyFile(FileSystem* src_fs, const std::string& src,
+                                FileSystem* target_fs, const std::string& target) {
+  std::unique_ptr<RandomAccessFile> src_file;
+  absl::Status s = src_fs->NewRandomAccessFile(src, &src_file);
+  if (!s.ok()) {
+    return s;
+  }
+
+  // When `target` points to a directory, we need to create a file within.
+  std::string target_name;
+  if (target_fs->IsDirectory(target).ok()) {
+    target_name = JoinPath(target, Basename(src));
+  } else {
+    target_name = target;
+  }
+
+  std::unique_ptr<WritableFile> target_file;
+  s = target_fs->NewWritableFile(target_name, &target_file);
+  if (!s.ok()) {
+    return s;
+  }
+
+  uint64_t offset = 0;
+  std::unique_ptr<char[]> scratch(new char[kCopyFileBufferSize]);
+  s = absl::OkStatus();
+  while (s.ok()) {
+    absl::string_view result;
+    s = src_file->Read(offset, kCopyFileBufferSize, &result, scratch.get());
+    if (!(s.ok() || absl::IsOutOfRange(s))) {
+      return s;
+    }
+    s = target_file->Append(result);
+    if (!s.ok()) {
+      return s;
+    }
+    offset += result.size();
+  }
+  return target_file->Close();
+}

+}  // namespace gtl
diff --git a/gtl/file_system.h b/gtl/file_system.h
index 0ccc705..155a5b1 100644
--- a/gtl/file_system.h
+++ b/gtl/file_system.h
@@ -24,13 +24,8 @@ limitations under the License.
 #include <utility>
 #include <vector>

-#include "gtl/cord.h"
-#include "gtl/errors.h"
+#include "third_party/absl/status/status.h"
 #include "gtl/file_statistics.h"
-#include "gtl/macros.h"
-#include "gtl/platform.h"
-#include "gtl/stringpiece.h"
-#include "gtl/types.h"

 #ifdef OS_WIN
 #undef DeleteFile
@@ -38,7 +33,7 @@ limitations under the License.
 #undef TranslateName
 #endif

-
+namespace gtl {

 class RandomAccessFile;
 class ReadOnlyMemoryRegion;
@@ -61,8 +56,8 @@ class FileSystem {
   ///
   /// The ownership of the returned RandomAccessFile is passed to the caller
   /// and the object should be deleted when is not used.
-  virtual tensorflow::Status NewRandomAccessFile(
-      const string& fname, std::unique_ptr<RandomAccessFile>* result) = 0;
+  virtual absl::Status NewRandomAccessFile(
+      const std::string& fname, std::unique_ptr<RandomAccessFile>* result) = 0;

   /// \brief Creates an object that writes to a new file with the specified
   /// name.
@@ -76,8 +71,8 @@ class FileSystem {
   ///
   /// The ownership of the returned WritableFile is passed to the caller
   /// and the object should be deleted when is not used.
-  virtual tensorflow::Status NewWritableFile(
-      const string& fname, std::unique_ptr<WritableFile>* result) = 0;
+  virtual absl::Status NewWritableFile(
+      const std::string& fname, std::unique_ptr<WritableFile>* result) = 0;

   /// \brief Creates an object that either appends to an existing file, or
   /// writes to a new file (if the file does not exist to begin with).
@@ -90,8 +85,8 @@ class FileSystem {
   ///
   /// The ownership of the returned WritableFile is passed to the caller
   /// and the object should be deleted when is not used.
-  virtual tensorflow::Status NewAppendableFile(
-      const string& fname, std::unique_ptr<WritableFile>* result) = 0;
+  virtual absl::Status NewAppendableFile(
+      const std::string& fname, std::unique_ptr<WritableFile>* result) = 0;

   /// \brief Creates a readonly region of memory with the file context.
   ///
@@ -103,23 +98,23 @@ class FileSystem {
   ///
   /// The ownership of the returned ReadOnlyMemoryRegion is passed to the caller
   /// and the object should be deleted when is not used.
-  virtual tensorflow::Status NewReadOnlyMemoryRegionFromFile(
-      const string& fname, std::unique_ptr<ReadOnlyMemoryRegion>* result) = 0;
+  virtual absl::Status NewReadOnlyMemoryRegionFromFile(
+      const std::string& fname, std::unique_ptr<ReadOnlyMemoryRegion>* result) = 0;

   /// Returns OK if the named path exists and NOT_FOUND otherwise.
-  virtual tensorflow::Status FileExists(const string& fname) = 0;
+  virtual absl::Status FileExists(const std::string& fname) = 0;

   /// Returns true if all the listed files exist, false otherwise.
   /// if status is not null, populate the vector with a detailed status
   /// for each file.
-  virtual bool FilesExist(const std::vector<string>& files,
-                          std::vector<Status>* status);
+  virtual bool FilesExist(const std::vector<std::string>& files,
+                          std::vector<absl::Status>* status);

   /// \brief Returns the immediate children in the given directory.
   ///
   /// The returned paths are relative to 'dir'.
-  virtual tensorflow::Status GetChildren(const string& dir,
-                                         std::vector<string>* result) = 0;
+  virtual absl::Status GetChildren(const std::string& dir,
+                                         std::vector<std::string>* result) = 0;

   /// \brief Given a pattern, stores in *results the set of paths that matches
   /// that pattern. *results is cleared.
@@ -143,29 +138,29 @@ class FileSystem {
   ///  * OK - no errors
   ///  * UNIMPLEMENTED - Some underlying functions (like GetChildren) are not
   ///                    implemented
-  virtual tensorflow::Status GetMatchingPaths(const string& pattern,
-                                              std::vector<string>* results) = 0;
+  virtual absl::Status GetMatchingPaths(const std::string& pattern,
+                                        std::vector<std::string>* results) = 0;

   /// \brief Checks if the given filename matches the pattern.
   ///
   /// This function provides the equivalent of posix fnmatch, however it is
   /// implemented without fnmatch to ensure that this can be used for cloud
   /// filesystems on windows. For windows filesystems, it uses PathMatchSpec.
-  virtual bool Match(const string& filename, const string& pattern);
+  virtual bool Match(const std::string& filename, const std::string& pattern);

   /// \brief Obtains statistics for the given path.
-  virtual tensorflow::Status Stat(const string& fname,
+  virtual absl::Status Stat(const std::string& fname,
                                   FileStatistics* stat) = 0;

   /// \brief Deletes the named file.
-  virtual tensorflow::Status DeleteFile(const string& fname) = 0;
+  virtual absl::Status DeleteFile(const std::string& fname) = 0;

   /// \brief Creates the specified directory.
   /// Typical return codes:
   ///  * OK - successfully created the directory.
   ///  * ALREADY_EXISTS - directory with name dirname already exists.
   ///  * PERMISSION_DENIED - dirname is not writable.
-  virtual tensorflow::Status CreateDir(const string& dirname) = 0;
+  virtual absl::Status CreateDir(const std::string& dirname) = 0;

   /// \brief Creates the specified directory and all the necessary
   /// subdirectories.
@@ -173,10 +168,10 @@ class FileSystem {
   ///  * OK - successfully created the directory and sub directories, even if
   ///         they were already created.
   ///  * PERMISSION_DENIED - dirname or some subdirectory is not writable.
-  virtual tensorflow::Status RecursivelyCreateDir(const string& dirname);
+  virtual absl::Status RecursivelyCreateDir(const std::string& dirname);

   /// \brief Deletes the specified directory.
-  virtual tensorflow::Status DeleteDir(const string& dirname) = 0;
+  virtual absl::Status DeleteDir(const std::string& dirname) = 0;

   /// \brief Deletes the specified directory and all subdirectories and files
   /// underneath it. This is accomplished by traversing the directory tree
@@ -202,20 +197,20 @@ class FileSystem {
   ///  * PERMISSION_DENIED - dirname or some descendant is not writable
   ///  * UNIMPLEMENTED - Some underlying functions (like Delete) are not
   ///                    implemented
-  virtual tensorflow::Status DeleteRecursively(const string& dirname,
-                                               int64* undeleted_files,
-                                               int64* undeleted_dirs);
+  virtual absl::Status DeleteRecursively(const std::string& dirname,
+                                         int64_t* undeleted_files,
+                                         int64_t* undeleted_dirs);

   /// \brief Stores the size of `fname` in `*file_size`.
-  virtual tensorflow::Status GetFileSize(const string& fname,
-                                         uint64* file_size) = 0;
+  virtual absl::Status GetFileSize(const std::string& fname,
+                                   uint64_t* file_size) = 0;

   /// \brief Overwrites the target if it exists.
-  virtual tensorflow::Status RenameFile(const string& src,
-                                        const string& target) = 0;
+  virtual absl::Status RenameFile(const std::string& src,
+                                  const std::string& target) = 0;

   /// \brief Copy the src to target.
-  virtual tensorflow::Status CopyFile(const string& src, const string& target);
+  virtual absl::Status CopyFile(const std::string& src, const std::string& target);

   /// \brief Translate an URI to a filename for the FileSystem implementation.
   ///
@@ -224,8 +219,8 @@ class FileSystem {
   /// This respects relative vs. absolute paths, but does not
   /// invoke any system calls (getcwd(2)) in order to resolve relative
   /// paths with respect to the actual working directory.  That is, this is
-  /// purely string manipulation, completely independent of process state.
-  virtual string TranslateName(const string& name) const;
+  /// purely std::string manipulation, completely independent of process state.
+  virtual std::string TranslateName(const std::string& name) const;

   /// \brief Returns whether the given path is a directory or not.
   ///
@@ -235,7 +230,7 @@ class FileSystem {
   ///  * NOT_FOUND - The path entry does not exist.
   ///  * PERMISSION_DENIED - Insufficient permissions.
   ///  * UNIMPLEMENTED - The file factory doesn't support directories.
-  virtual tensorflow::Status IsDirectory(const string& fname);
+  virtual absl::Status IsDirectory(const std::string& fname);

   /// \brief Returns whether the given path is on a file system
   /// that has atomic move capabilities. This can be used
@@ -247,7 +242,7 @@ class FileSystem {
   ///         so has_atomic_move holds the above information.
   ///  * UNIMPLEMENTED - The file system of the path hasn't been implemented in
   ///  TF
-  virtual Status HasAtomicMove(const string& path, bool* has_atomic_move);
+  virtual absl::Status HasAtomicMove(const std::string& path, bool* has_atomic_move);

   /// \brief Flushes any cached filesystem objects from memory.
   virtual void FlushCaches();
@@ -287,20 +282,20 @@ class FileSystem {
   /// NOTE: This respects relative vs. absolute paths, but does not
   /// invoke any system calls (getcwd(2)) in order to resolve relative
   /// paths with respect to the actual working directory.  That is, this is
-  /// purely string manipulation, completely independent of process state.
-  string CleanPath(absl::string_view path) const;
+  /// purely std::string manipulation, completely independent of process state.
+  std::string CleanPath(absl::string_view path) const;

   /// \brief Creates a URI from a scheme, host, and path.
   ///
   /// If the scheme is empty, we just return the path.
-  string CreateURI(absl::string_view scheme, absl::string_view host,
+  std::string CreateURI(absl::string_view scheme, absl::string_view host,
                    absl::string_view path) const;

   ///  \brief Creates a temporary file name with an extension.
-  string GetTempFilename(const string& extension) const;
+  std::string GetTempFilename(const std::string& extension) const;

   /// \brief Return true if path is absolute.
-  bool IsAbsolutePath(tensorflow::absl::string_view path) const;
+  bool IsAbsolutePath(absl::string_view path) const;

 #ifndef SWIG  // variadic templates
   /// \brief Join multiple paths together.
@@ -315,16 +310,16 @@ class FileSystem {
   ///  '/foo', '/bar'             | /foo/bar
   ///
   /// Usage:
-  /// string path = io::JoinPath("/mydir", filename);
-  /// string path = io::JoinPath(FLAGS_test_srcdir, filename);
-  /// string path = io::JoinPath("/full", "path", "to", "filename");
+  /// std::string path = io::JoinPath("/mydir", filename);
+  /// std::string path = io::JoinPath(FLAGS_test_srcdir, filename);
+  /// std::string path = io::JoinPath("/full", "path", "to", "filename");
   template <typename... T>
-  string JoinPath(const T&... args) {
+  std::string JoinPath(const T&... args) {
     return JoinPathImpl({args...});
   }
 #endif /* SWIG */

-  string JoinPathImpl(std::initializer_list<tensorflow::absl::string_view> paths);
+  std::string JoinPathImpl(std::initializer_list<absl::string_view> paths);

   /// \brief Populates the scheme, host, and path from a URI.
   ///
@@ -332,14 +327,14 @@ class FileSystem {
   /// contents of uri, even if empty.
   ///
   /// Corner cases:
-  /// - If the URI is invalid, scheme and host are set to empty strings and the
-  ///  passed string is assumed to be a path
+  /// - If the URI is invalid, scheme and host are set to empty std::strings and the
+  ///  passed std::string is assumed to be a path
   /// - If the URI omits the path (e.g. file://host), then the path is left
   /// empty.
   void ParseURI(absl::string_view remaining, absl::string_view* scheme, absl::string_view* host,
                 absl::string_view* path) const;

-  FileSystem() {}
+  FileSystem() = default;

   virtual ~FileSystem() = default;
 };
@@ -354,8 +349,8 @@ class RandomAccessFile {
   ///
   /// This is an optional operation that may not be implemented by every
   /// filesystem.
-  virtual tensorflow::Status Name(absl::string_view* result) const {
-    return errors::Unimplemented("This filesystem does not support Name()");
+  virtual absl::Status Name(absl::string_view* result) const {
+    return absl::UnimplementedError("This filesystem does not support Name()");
   }

   /// \brief Reads up to `n` bytes from the file starting at `offset`.
@@ -373,22 +368,20 @@ class RandomAccessFile {
   /// because of EOF.
   ///
   /// Safe for concurrent use by multiple threads.
-  virtual tensorflow::Status Read(uint64 offset, size_t n, absl::string_view* result,
+  virtual absl::Status Read(uint64_t offset, size_t n, absl::string_view* result,
                                   char* scratch) const = 0;

-  // TODO(ebrevdo): Remove this ifdef when absl is updated.
-#if defined(PLATFORM_GOOGLE)
   /// \brief Read up to `n` bytes from the file starting at `offset`.
-  virtual tensorflow::Status Read(uint64 offset, size_t n,
+  virtual absl::Status Read(uint64_t offset, size_t n,
                                   absl::Cord* cord) const {
-    return errors::Unimplemented(
-        "Read(uint64, size_t, absl::Cord*) is not "
+    return absl::UnimplementedError(
+        "Read(uint64_t, size_t, absl::Cord*) is not "
         "implemented");
   }
-#endif

  private:
-  TF_DISALLOW_COPY_AND_ASSIGN(RandomAccessFile);
+  RandomAccessFile(const RandomAccessFile&) = delete;
+  RandomAccessFile& operator=(const RandomAccessFile&) = delete;
 };

 /// \brief A file abstraction for sequential writing.
@@ -401,15 +394,12 @@ class WritableFile {
   virtual ~WritableFile() = default;

   /// \brief Append 'data' to the file.
-  virtual tensorflow::Status Append(absl::string_view data) = 0;
+  virtual absl::Status Append(absl::string_view data) = 0;

-  // TODO(ebrevdo): Remove this ifdef when absl is updated.
-#if defined(PLATFORM_GOOGLE)
   // \brief Append 'data' to the file.
-  virtual tensorflow::Status Append(const absl::Cord& cord) {
-    return errors::Unimplemented("Append(absl::Cord) is not implemented");
+  virtual absl::Status Append(const absl::Cord& cord) {
+    return absl::UnimplementedError("Append(absl::Cord) is not implemented");
   }
-#endif

   /// \brief Close the file.
   ///
@@ -418,7 +408,7 @@ class WritableFile {
   /// Typical return codes (not guaranteed to be exhaustive):
   ///  * OK
   ///  * Other codes, as returned from Flush()
-  virtual tensorflow::Status Close() = 0;
+  virtual absl::Status Close() = 0;

   /// \brief Flushes the file and optionally syncs contents to filesystem.
   ///
@@ -430,14 +420,14 @@ class WritableFile {
   /// eventually flush the contents.  If the OS or machine crashes
   /// after a successful flush, the contents may or may not be
   /// persisted, depending on the implementation.
-  virtual tensorflow::Status Flush() = 0;
+  virtual absl::Status Flush() = 0;

   // \brief Returns the name of the file.
   ///
   /// This is an optional operation that may not be implemented by every
   /// filesystem.
-  virtual tensorflow::Status Name(absl::string_view* result) const {
-    return errors::Unimplemented("This filesystem does not support Name()");
+  virtual absl::Status Name(absl::string_view* result) const {
+    return absl::UnimplementedError("This filesystem does not support Name()");
   }

   /// \brief Syncs contents of file to filesystem.
@@ -446,20 +436,21 @@ class WritableFile {
   /// of the file have been persisted to the filesystem; if the OS
   /// or machine crashes after a successful Sync, the contents should
   /// be properly saved.
-  virtual tensorflow::Status Sync() = 0;
+  virtual absl::Status Sync() = 0;

   /// \brief Retrieves the current write position in the file, or -1 on
   /// error.
   ///
   /// This is an optional operation, subclasses may choose to return
   /// errors::Unimplemented.
-  virtual tensorflow::Status Tell(int64* position) {
+  virtual absl::Status Tell(int64_t* position) {
     *position = -1;
-    return errors::Unimplemented("This filesystem does not support Tell()");
+    return absl::UnimplementedError("This filesystem does not support Tell()");
   }

  private:
-  TF_DISALLOW_COPY_AND_ASSIGN(WritableFile);
+  WritableFile(const WritableFile&) = delete;
+  WritableFile& operator=(const WritableFile&) = delete;
 };

 /// \brief A readonly memmapped file abstraction.
@@ -475,7 +466,7 @@ class ReadOnlyMemoryRegion {
   virtual const void* data() = 0;

   /// \brief Returns the length of the memory region in bytes.
-  virtual uint64 length() = 0;
+  virtual uint64_t length() = 0;
 };

 /// \brief A registry for file system implementations.
@@ -506,15 +497,20 @@ class FileSystemRegistry {
   typedef std::function<FileSystem*()> Factory;

   virtual ~FileSystemRegistry() = default;
-  virtual tensorflow::Status Register(const std::string& scheme,
+  virtual absl::Status Register(const std::string& scheme,
                                       Factory factory) = 0;
-  virtual tensorflow::Status Register(
+  virtual absl::Status Register(
       const std::string& scheme, std::unique_ptr<FileSystem> filesystem) = 0;
   virtual FileSystem* Lookup(const std::string& scheme) = 0;
-  virtual tensorflow::Status GetRegisteredFileSystemSchemes(
+  virtual absl::Status GetRegisteredFileSystemSchemes(
       std::vector<std::string>* schemes) = 0;
 };

+/// A utility routine: copy contents of `src` in file system `src_fs`
+/// to `target` in file system `target_fs`.
+absl::Status FileSystemCopyFile(FileSystem* src_fs, const std::string& src,
+                                FileSystem* target_fs, const std::string& target);

+}  // namespace gtl

 #endif  // GTL_FILE_SYSTEM_H_
diff --git a/gtl/file_system_helper.cc b/gtl/file_system_helper.cc
index b68cd5d..09b4c28 100644
--- a/gtl/file_system_helper.cc
+++ b/gtl/file_system_helper.cc
@@ -15,19 +15,18 @@ limitations under the License.

 #include "gtl/file_system_helper.h"

+#include <algorithm>
 #include <deque>
+#include <functional>
 #include <string>
 #include <vector>

-#include "gtl/env.h"
+#include "third_party/absl/status/status.h"
+#include "third_party/absl/strings/match.h"
 #include "gtl/file_system.h"
 #include "gtl/path.h"
-#include "gtl/platform.h"
-#include "gtl/status.h"
-#include "gtl/str_util.h"
-#include "gtl/threadpool.h"
-

+namespace gtl {
 namespace internal {

 namespace {
@@ -37,7 +36,8 @@ constexpr int kNumThreads = 8;
 // Run a function in parallel using a ThreadPool, but skip the ThreadPool
 // on the iOS platform due to its problems with more than a few threads.
 void ForEach(int first, int last, const std::function<void(int)>& f) {
-#if TARGET_OS_IPHONE
+#if 1
+  static_cast<void>(kNumThreads);  // Eliminate warning.
   for (int i = first; i < last; i++) {
     f(i);
   }
@@ -52,38 +52,38 @@ void ForEach(int first, int last, const std::function<void(int)>& f) {

 }  // namespace

-Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,
-                        std::vector<string>* results) {
+absl::Status GetMatchingPaths(FileSystem* fs, const std::string& pattern,
+                              std::vector<std::string>* results) {
   results->clear();
   // Find the fixed prefix by looking for the first wildcard.
-  string fixed_prefix = pattern.substr(0, pattern.find_first_of("*?[\\"));
-  string eval_pattern = pattern;
-  std::vector<string> all_files;
-  string dir(io::Dirname(fixed_prefix));
+  std::string fixed_prefix = pattern.substr(0, pattern.find_first_of("*?[\\"));
+  std::string eval_pattern = pattern;
+  std::vector<std::string> all_files;
+  std::string dir(Dirname(fixed_prefix));
   // If dir is empty then we need to fix up fixed_prefix and eval_pattern to
   // include . as the top level directory.
   if (dir.empty()) {
     dir = ".";
-    fixed_prefix = io::JoinPath(dir, fixed_prefix);
-    eval_pattern = io::JoinPath(dir, pattern);
+    fixed_prefix = JoinPath(dir, fixed_prefix);
+    eval_pattern = JoinPath(dir, pattern);
   }

   // Setup a BFS to explore everything under dir.
-  std::deque<string> dir_q;
+  std::deque<std::string> dir_q;
   dir_q.push_back(dir);
-  Status ret;  // Status to return.
+  absl::Status ret;  // Status to return.
   // children_dir_status holds is_dir status for children. It can have three
   // possible values: OK for true; FAILED_PRECONDITION for false; CANCELLED
   // if we don't calculate IsDirectory (we might do that because there isn't
   // any point in exploring that child path).
-  std::vector<Status> children_dir_status;
+  std::vector<absl::Status> children_dir_status;
   while (!dir_q.empty()) {
-    string current_dir = dir_q.front();
+    std::string current_dir = dir_q.front();
     dir_q.pop_front();
-    std::vector<string> children;
-    Status s = fs->GetChildren(current_dir, &children);
+    std::vector<std::string> children;
+    absl::Status s = fs->GetChildren(current_dir, &children);
     // In case PERMISSION_DENIED is encountered, we bail here.
-    if (s.code() == tensorflow::error::PERMISSION_DENIED) {
+    if (absl::IsPermissionDenied(s)) {
       continue;
     }
     ret.Update(s);
@@ -93,20 +93,20 @@ Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,
     ForEach(0, children.size(),
             [fs, &current_dir, &children, &fixed_prefix,
              &children_dir_status](int i) {
-              const string child_path = io::JoinPath(current_dir, children[i]);
+              const std::string child_path = JoinPath(current_dir, children[i]);
               // In case the child_path doesn't start with the fixed_prefix then
               // we don't need to explore this path.
               if (!absl::StartsWith(child_path, fixed_prefix)) {
-                children_dir_status[i] = Status(tensorflow::error::CANCELLED,
-                                                "Operation not needed");
+                children_dir_status[i] =
+                    absl::CancelledError("Operation not needed");
               } else {
                 children_dir_status[i] = fs->IsDirectory(child_path);
               }
             });
     for (int i = 0; i < children.size(); ++i) {
-      const string child_path = io::JoinPath(current_dir, children[i]);
+      const std::string child_path = JoinPath(current_dir, children[i]);
       // If the IsDirectory call was cancelled we bail.
-      if (children_dir_status[i].code() == tensorflow::error::CANCELLED) {
+      if (absl::IsCancelled(children_dir_status[i])) {
         continue;
       }
       // If the child is a directory add it to the queue.
@@ -127,4 +127,4 @@ Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,
 }

 }  // namespace internal
-
+}  // namespace gtl
diff --git a/gtl/file_system_helper.h b/gtl/file_system_helper.h
index 247df1b..5a66587 100644
--- a/gtl/file_system_helper.h
+++ b/gtl/file_system_helper.h
@@ -19,12 +19,11 @@ limitations under the License.
 #include <string>
 #include <vector>

-#include "gtl/status.h"
-
+#include "third_party/absl/status/status.h"

+namespace gtl {

 class FileSystem;
-class Env;

 namespace internal {

@@ -42,10 +41,10 @@ namespace internal {
 //   results: will be cleared and may not be null.
 //
 // Returns an error status if any call to 'fs' failed.
-Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,
-                        std::vector<string>* results);
+absl::Status GetMatchingPaths(FileSystem* fs, const std::string& pattern,
+                              std::vector<std::string>* results);

 }  // namespace internal
-
+}  // namespace gtl

 #endif  // GTL_FILE_SYSTEM_HELPER_H_
diff --git a/gtl/file_system_test.cc b/gtl/file_system_test.cc
index 64f1da1..efa88ab 100644
--- a/gtl/file_system_test.cc
+++ b/gtl/file_system_test.cc
@@ -17,151 +17,155 @@ limitations under the License.

 #include <sys/stat.h>

-#include "tensorflow/core/lib/core/status_test_util.h"
+#include "third_party/absl/status/status.h"
+#include "third_party/absl/strings/match.h"
+#include "third_party/absl/strings/str_join.h"
+#include "third_party/absl/strings/str_split.h"
+#include "third_party/glog/logging.h"
+#include "gtest/gtest.h"
 #include "gtl/null_file_system.h"
 #include "gtl/path.h"
-#include "gtl/str_util.h"
-#include "gtl/strcat.h"
-#include "gtest/gtest.h"
-

+// Macros for testing the results of functions that return tensorflow::Status.
+#define TF_EXPECT_OK(statement) \
+  EXPECT_TRUE((statement).ok())

 static const char* const kPrefix = "ipfs://solarsystem";

 // A file system that has Planets, Satellites and Sub Satellites. Sub satellites
 // cannot have children further.
-class InterPlanetaryFileSystem : public NullFileSystem {
+class InterPlanetaryFileSystem : public gtl::NullFileSystem {
  public:
-  Status FileExists(const string& fname) override {
-    string parsed_path;
+  absl::Status FileExists(const std::string& fname) override {
+    std::string parsed_path;
     ParsePath(fname, &parsed_path);
     if (BodyExists(parsed_path)) {
-      return Status::OK();
+      return absl::OkStatus();
     }
-    return Status(tensorflow::error::NOT_FOUND, "File does not exist");
+    return absl::NotFoundError("File does not exist");
   }

   // Adds the dir to the parent's children list and creates an entry for itself.
-  Status CreateDir(const string& dirname) override {
-    string parsed_path;
+  absl::Status CreateDir(const std::string& dirname) override {
+    std::string parsed_path;
     ParsePath(dirname, &parsed_path);
     // If the directory already exists, throw an error.
     if (celestial_bodies_.find(parsed_path) != celestial_bodies_.end()) {
-      return Status(tensorflow::error::ALREADY_EXISTS,
-                    "dirname already exists.");
+      return absl::AlreadyExistsError("dirname already exists.");
     }
-    std::vector<string> split_path = str_util::Split(parsed_path, '/');
+    std::vector<std::string> split_path = absl::StrSplit(parsed_path, '/');
     // If the path is too long then we don't support it.
     if (split_path.size() > 3) {
-      return Status(tensorflow::error::INVALID_ARGUMENT, "Bad dirname");
+      return absl::InvalidArgumentError("Bad dirname");
     }
     if (split_path.empty()) {
-      return Status::OK();
+      return absl::OkStatus();
     }
     if (split_path.size() == 1) {
       celestial_bodies_[""].insert(parsed_path);
       celestial_bodies_.insert(
-          std::pair<string, std::set<string>>(parsed_path, {}));
-      return Status::OK();
+          std::pair<std::string, std::set<std::string>>(parsed_path, {}));
+      return absl::OkStatus();
     }
     if (split_path.size() == 2) {
       if (!BodyExists(split_path[0])) {
-        return Status(tensorflow::error::FAILED_PRECONDITION,
-                      "Base dir not created");
+        return absl::FailedPreconditionError("Base dir not created");
       }
       celestial_bodies_[split_path[0]].insert(split_path[1]);
       celestial_bodies_.insert(
-          std::pair<string, std::set<string>>(parsed_path, {}));
-      return Status::OK();
+          std::pair<std::string, std::set<std::string>>(parsed_path, {}));
+      return absl::OkStatus();
     }
     if (split_path.size() == 3) {
-      const string& parent_path = this->JoinPath(split_path[0], split_path[1]);
+      const std::string& parent_path = this->JoinPath(split_path[0], split_path[1]);
       if (!BodyExists(parent_path)) {
-        return Status(tensorflow::error::FAILED_PRECONDITION,
-                      "Base dir not created");
+        return absl::FailedPreconditionError("Base dir not created");
       }
       celestial_bodies_[parent_path].insert(split_path[2]);
       celestial_bodies_.insert(
-          std::pair<string, std::set<string>>(parsed_path, {}));
-      return Status::OK();
+          std::pair<std::string, std::set<std::string>>(parsed_path, {}));
+      return absl::OkStatus();
     }
-    return Status(tensorflow::error::FAILED_PRECONDITION, "Failed to create");
+    return absl::FailedPreconditionError("Failed to create");
   }

-  Status IsDirectory(const string& dirname) override {
-    string parsed_path;
+  absl::Status IsDirectory(const std::string& dirname) override {
+    std::string parsed_path;
     ParsePath(dirname, &parsed_path);
     // Simulate evil_directory has bad permissions by throwing a LOG(FATAL)
     if (parsed_path == "evil_directory") {
       LOG(FATAL) << "evil_directory cannot be accessed";
     }
-    std::vector<string> split_path = str_util::Split(parsed_path, '/');
+    std::vector<std::string> split_path = absl::StrSplit(parsed_path, '/');
     if (split_path.size() > 2) {
-      return Status(tensorflow::error::FAILED_PRECONDITION, "Not a dir");
+      return absl::FailedPreconditionError("Not a dir");
     }
     if (celestial_bodies_.find(parsed_path) != celestial_bodies_.end()) {
-      return Status::OK();
+      return absl::OkStatus();
     }
-    return Status(tensorflow::error::FAILED_PRECONDITION, "Not a dir");
+    return absl::FailedPreconditionError("Not a dir");
   }

-  Status GetChildren(const string& dir, std::vector<string>* result) override {
-    TF_RETURN_IF_ERROR(IsDirectory(dir));
-    string parsed_path;
+  absl::Status GetChildren(const std::string& dir, std::vector<std::string>* result) override {
+    absl::Status s = IsDirectory(dir);
+    if (!s.ok()) {
+      return s;
+    }
+    std::string parsed_path;
     ParsePath(dir, &parsed_path);
     result->insert(result->begin(), celestial_bodies_[parsed_path].begin(),
                    celestial_bodies_[parsed_path].end());
-    return Status::OK();
+    return absl::OkStatus();
   }

  private:
-  bool BodyExists(const string& name) {
+  bool BodyExists(const std::string& name) {
     return celestial_bodies_.find(name) != celestial_bodies_.end();
   }

-  void ParsePath(const string& name, string* parsed_path) {
+  void ParsePath(const std::string& name, std::string* parsed_path) {
     absl::string_view scheme, host, path;
     this->ParseURI(name, &scheme, &host, &path);
     ASSERT_EQ(scheme, "ipfs");
     ASSERT_EQ(host, "solarsystem");
     absl::ConsumePrefix(&path, "/");
-    *parsed_path = string(path);
+    *parsed_path = std::string(path);
   }

-  std::map<string, std::set<string>> celestial_bodies_ = {
-      std::pair<string, std::set<string>>(
+  std::map<std::string, std::set<std::string>> celestial_bodies_ = {
+      std::pair<std::string, std::set<std::string>>(
           "", {"Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn",
                "Uranus", "Neptune"}),
-      std::pair<string, std::set<string>>("Mercury", {}),
-      std::pair<string, std::set<string>>("Venus", {}),
-      std::pair<string, std::set<string>>("Earth", {"Moon"}),
-      std::pair<string, std::set<string>>("Mars", {}),
-      std::pair<string, std::set<string>>("Jupiter",
+      std::pair<std::string, std::set<std::string>>("Mercury", {}),
+      std::pair<std::string, std::set<std::string>>("Venus", {}),
+      std::pair<std::string, std::set<std::string>>("Earth", {"Moon"}),
+      std::pair<std::string, std::set<std::string>>("Mars", {}),
+      std::pair<std::string, std::set<std::string>>("Jupiter",
                                           {"Europa", "Io", "Ganymede"}),
-      std::pair<string, std::set<string>>("Saturn", {}),
-      std::pair<string, std::set<string>>("Uranus", {}),
-      std::pair<string, std::set<string>>("Neptune", {}),
-      std::pair<string, std::set<string>>("Earth/Moon", {}),
-      std::pair<string, std::set<string>>("Jupiter/Europa", {}),
-      std::pair<string, std::set<string>>("Jupiter/Io", {}),
-      std::pair<string, std::set<string>>("Jupiter/Ganymede", {})};
+      std::pair<std::string, std::set<std::string>>("Saturn", {}),
+      std::pair<std::string, std::set<std::string>>("Uranus", {}),
+      std::pair<std::string, std::set<std::string>>("Neptune", {}),
+      std::pair<std::string, std::set<std::string>>("Earth/Moon", {}),
+      std::pair<std::string, std::set<std::string>>("Jupiter/Europa", {}),
+      std::pair<std::string, std::set<std::string>>("Jupiter/Io", {}),
+      std::pair<std::string, std::set<std::string>>("Jupiter/Ganymede", {})};
 };

-// Returns all the matched entries as a comma separated string removing the
+// Returns all the matched entries as a comma separated std::string removing the
 // common prefix of BaseDir().
-string Match(InterPlanetaryFileSystem* ipfs, const string& suffix_pattern) {
-  std::vector<string> results;
-  Status s =
+std::string Match(InterPlanetaryFileSystem* ipfs, const std::string& suffix_pattern) {
+  std::vector<std::string> results;
+  absl::Status s =
       ipfs->GetMatchingPaths(ipfs->JoinPath(kPrefix, suffix_pattern), &results);
   if (!s.ok()) {
     return s.ToString();
   } else {
     std::vector<absl::string_view> trimmed_results;
     std::sort(results.begin(), results.end());
-    for (const string& result : results) {
+    for (const std::string& result : results) {
       absl::string_view trimmed_result(result);
       EXPECT_TRUE(
-          absl::ConsumePrefix(&trimmed_result, strings::StrCat(kPrefix, "/")));
+          absl::ConsumePrefix(&trimmed_result, absl::StrCat(kPrefix, "/")));
       trimmed_results.push_back(trimmed_result);
     }
     return absl::StrJoin(trimmed_results, ",");
@@ -253,7 +257,7 @@ TEST(InterPlanetaryFileSystemTest, MatchMultipleWildcards) {

 TEST(InterPlanetaryFileSystemTest, RecursivelyCreateAlreadyExistingDir) {
   InterPlanetaryFileSystem ipfs;
-  const string dirname = ipfs.JoinPath(kPrefix, "match-00/abc/00");
+  const std::string dirname = ipfs.JoinPath(kPrefix, "match-00/abc/00");
   TF_EXPECT_OK(ipfs.RecursivelyCreateDir(dirname));
   // We no longer check for recursively creating the directory again because
   // `ipfs.IsDirectory` is badly implemented, fixing it will break other tests
@@ -263,36 +267,36 @@ TEST(InterPlanetaryFileSystemTest, RecursivelyCreateAlreadyExistingDir) {

 TEST(InterPlanetaryFileSystemTest, HasAtomicMove) {
   InterPlanetaryFileSystem ipfs;
-  const string dirname = io::JoinPath(kPrefix, "match-00/abc/00");
+  const std::string dirname = gtl::JoinPath(kPrefix, "match-00/abc/00");
   bool has_atomic_move;
   TF_EXPECT_OK(ipfs.HasAtomicMove(dirname, &has_atomic_move));
   EXPECT_EQ(has_atomic_move, true);
 }

 // A simple file system with a root directory and a single file underneath it.
-class TestFileSystem : public NullFileSystem {
+class TestFileSystem : public gtl::NullFileSystem {
  public:
   // Only allow for a single root directory.
-  Status IsDirectory(const string& dirname) override {
+  absl::Status IsDirectory(const std::string& dirname) override {
     if (dirname == "." || dirname.empty()) {
-      return Status::OK();
+      return absl::OkStatus();
     }
-    return Status(tensorflow::error::FAILED_PRECONDITION, "Not a dir");
+    return absl::FailedPreconditionError("Not a dir");
   }

   // Simulating a FS with a root dir and a single file underneath it.
-  Status GetChildren(const string& dir, std::vector<string>* result) override {
+  absl::Status GetChildren(const std::string& dir, std::vector<std::string>* result) override {
     if (dir == "." || dir.empty()) {
       result->push_back("test");
     }
-    return Status::OK();
+    return absl::OkStatus();
   }
 };

 // Making sure that ./<pattern> and <pattern> have the same result.
 TEST(TestFileSystemTest, RootDirectory) {
   TestFileSystem fs;
-  std::vector<string> results;
+  std::vector<std::string> results;
   auto ret = fs.GetMatchingPaths("./te*", &results);
   EXPECT_EQ(1, results.size());
   EXPECT_EQ("./test", results[0]);
diff --git a/gtl/null_file_system.h b/gtl/null_file_system.h
index f1f00f9..6d1f930 100644
--- a/gtl/null_file_system.h
+++ b/gtl/null_file_system.h
@@ -20,11 +20,12 @@ limitations under the License.
 #include <string>
 #include <vector>

-#include "gtl/env.h"
+#include "third_party/absl/status/status.h"
+#include "gtl/file_statistics.h"
 #include "gtl/file_system.h"
 #include "gtl/file_system_helper.h"

-
+namespace gtl {

 // START_SKIP_DOXYGEN

@@ -32,73 +33,73 @@ limitations under the License.
 // Degenerate file system that provides no implementations.
 class NullFileSystem : public FileSystem {
  public:
-  NullFileSystem() {}
+  NullFileSystem() = default;

   ~NullFileSystem() override = default;

-  Status NewRandomAccessFile(
-      const string& fname, std::unique_ptr<RandomAccessFile>* result) override {
-    return errors::Unimplemented("NewRandomAccessFile unimplemented");
+  absl::Status NewRandomAccessFile(
+      const std::string& fname, std::unique_ptr<RandomAccessFile>* result) override {
+    return absl::UnimplementedError("NewRandomAccessFile unimplemented");
   }

-  Status NewWritableFile(const string& fname,
+  absl::Status NewWritableFile(const std::string& fname,
                          std::unique_ptr<WritableFile>* result) override {
-    return errors::Unimplemented("NewWritableFile unimplemented");
+    return absl::UnimplementedError("NewWritableFile unimplemented");
   }

-  Status NewAppendableFile(const string& fname,
+  absl::Status NewAppendableFile(const std::string& fname,
                            std::unique_ptr<WritableFile>* result) override {
-    return errors::Unimplemented("NewAppendableFile unimplemented");
+    return absl::UnimplementedError("NewAppendableFile unimplemented");
   }

-  Status NewReadOnlyMemoryRegionFromFile(
-      const string& fname,
+  absl::Status NewReadOnlyMemoryRegionFromFile(
+      const std::string& fname,
       std::unique_ptr<ReadOnlyMemoryRegion>* result) override {
-    return errors::Unimplemented(
+    return absl::UnimplementedError(
         "NewReadOnlyMemoryRegionFromFile unimplemented");
   }

-  Status FileExists(const string& fname) override {
-    return errors::Unimplemented("FileExists unimplemented");
+  absl::Status FileExists(const std::string& fname) override {
+    return absl::UnimplementedError("FileExists unimplemented");
   }

-  Status GetChildren(const string& dir, std::vector<string>* result) override {
-    return errors::Unimplemented("GetChildren unimplemented");
+  absl::Status GetChildren(const std::string& dir, std::vector<std::string>* result) override {
+    return absl::UnimplementedError("GetChildren unimplemented");
   }

-  Status GetMatchingPaths(const string& pattern,
-                          std::vector<string>* results) override {
-    return internal::GetMatchingPaths(this, Env::Default(), pattern, results);
+  absl::Status GetMatchingPaths(const std::string& pattern,
+                          std::vector<std::string>* results) override {
+    return internal::GetMatchingPaths(this, pattern, results);
   }

-  Status DeleteFile(const string& fname) override {
-    return errors::Unimplemented("DeleteFile unimplemented");
+  absl::Status DeleteFile(const std::string& fname) override {
+    return absl::UnimplementedError("DeleteFile unimplemented");
   }

-  Status CreateDir(const string& dirname) override {
-    return errors::Unimplemented("CreateDir unimplemented");
+  absl::Status CreateDir(const std::string& dirname) override {
+    return absl::UnimplementedError("CreateDir unimplemented");
   }

-  Status DeleteDir(const string& dirname) override {
-    return errors::Unimplemented("DeleteDir unimplemented");
+  absl::Status DeleteDir(const std::string& dirname) override {
+    return absl::UnimplementedError("DeleteDir unimplemented");
   }

-  Status GetFileSize(const string& fname, uint64* file_size) override {
-    return errors::Unimplemented("GetFileSize unimplemented");
+  absl::Status GetFileSize(const std::string& fname, uint64_t* file_size) override {
+    return absl::UnimplementedError("GetFileSize unimplemented");
   }

-  Status RenameFile(const string& src, const string& target) override {
-    return errors::Unimplemented("RenameFile unimplemented");
+  absl::Status RenameFile(const std::string& src, const std::string& target) override {
+    return absl::UnimplementedError("RenameFile unimplemented");
   }

-  Status Stat(const string& fname, FileStatistics* stat) override {
-    return errors::Unimplemented("Stat unimplemented");
+  absl::Status Stat(const std::string& fname, FileStatistics* stat) override {
+    return absl::UnimplementedError("Stat unimplemented");
   }
 };
 #endif

 // END_SKIP_DOXYGEN

-
+}  // namespace gtl

 #endif  // GTL_NULL_FILE_SYSTEM_H_
diff --git a/gtl/posix_file_system.cc b/gtl/posix_file_system.cc
index 834dc65..e248fae 100644
--- a/gtl/posix_file_system.cc
+++ b/gtl/posix_file_system.cc
@@ -13,31 +13,188 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/

+#include "gtl/posix_file_system.h"
+
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <sys/mman.h>
-#if defined(__linux__)
-#include <sys/sendfile.h>
-#endif
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/types.h>
 #include <time.h>
 #include <unistd.h>

-#include "gtl/default/posix_file_system.h"
-#include "gtl/env.h"
-#include "gtl/error.h"
-#include "gtl/file_system_helper.h"
+#include "third_party/absl/status/status.h"
+#include "third_party/absl/strings/str_cat.h"
 #include "third_party/glog/logging.h"
-#include "gtl/status.h"
-#include "gtl/strcat.h"
-#include "tensorflow/core/protobuf/error_codes.pb.h"
+#include "config/config.h"
+#include "gtl/file_system_helper.h"
+
+#if OS_LINUX
+#include <sys/sendfile.h>
+#endif
+
+namespace gtl {
+namespace {
+
+// Copied from
+// https://github.com/tensorflow/tensorflow/blob/v2.2.0/tensorflow/core/platform/error.cc
+absl::StatusCode ErrnoToCode(int err_number) {
+  absl::StatusCode code;
+  switch (err_number) {
+    case 0:
+      code = absl::StatusCode::kOk;
+      break;
+    case EINVAL:        // Invalid argument
+    case ENAMETOOLONG:  // Filename too long
+    case E2BIG:         // Argument list too long
+    case EDESTADDRREQ:  // Destination address required
+    case EDOM:          // Mathematics argument out of domain of function
+    case EFAULT:        // Bad address
+    case EILSEQ:        // Illegal byte sequence
+    case ENOPROTOOPT:   // Protocol not available
+    case ENOSTR:        // Not a STREAM
+    case ENOTSOCK:      // Not a socket
+    case ENOTTY:        // Inappropriate I/O control operation
+    case EPROTOTYPE:    // Protocol wrong type for socket
+    case ESPIPE:        // Invalid seek
+      code = absl::StatusCode::kInvalidArgument;
+      break;
+    case ETIMEDOUT:  // Connection timed out
+    case ETIME:      // Timer expired
+      code = absl::StatusCode::kDeadlineExceeded;
+      break;
+    case ENODEV:  // No such device
+    case ENOENT:  // No such file or directory
+    case ENXIO:   // No such device or address
+    case ESRCH:   // No such process
+      code = absl::StatusCode::kNotFound;
+      break;
+    case EEXIST:         // File exists
+    case EADDRNOTAVAIL:  // Address not available
+    case EALREADY:       // Connection already in progress
+      code = absl::StatusCode::kAlreadyExists;
+      break;
+    case EPERM:   // Operation not permitted
+    case EACCES:  // Permission denied
+    case EROFS:   // Read only file system
+      code = absl::StatusCode::kPermissionDenied;
+      break;
+    case ENOTEMPTY:   // Directory not empty
+    case EISDIR:      // Is a directory
+    case ENOTDIR:     // Not a directory
+    case EADDRINUSE:  // Address already in use
+    case EBADF:       // Invalid file descriptor
+    case EBUSY:       // Device or resource busy
+    case ECHILD:      // No child processes
+    case EISCONN:     // Socket is connected
+#if !defined(_WIN32) && !defined(__HAIKU__)
+    case ENOTBLK:  // Block device required
+#endif
+    case ENOTCONN:  // The socket is not connected
+    case EPIPE:     // Broken pipe
+#if !defined(_WIN32)
+    case ESHUTDOWN:  // Cannot send after transport endpoint shutdown
+#endif
+    case ETXTBSY:  // Text file busy
+      code = absl::StatusCode::kFailedPrecondition;
+      break;
+    case ENOSPC:  // No space left on device
+#if !defined(_WIN32)
+    case EDQUOT:  // Disk quota exceeded
+#endif
+    case EMFILE:   // Too many open files
+    case EMLINK:   // Too many links
+    case ENFILE:   // Too many open files in system
+    case ENOBUFS:  // No buffer space available
+    case ENODATA:  // No message is available on the STREAM read queue
+    case ENOMEM:   // Not enough space
+    case ENOSR:    // No STREAM resources
+#if !defined(_WIN32) && !defined(__HAIKU__)
+    case EUSERS:  // Too many users
+#endif
+      code = absl::StatusCode::kResourceExhausted;
+      break;
+    case EFBIG:      // File too large
+    case EOVERFLOW:  // Value too large to be stored in data type
+    case ERANGE:     // Result too large
+      code = absl::StatusCode::kOutOfRange;
+      break;
+    case ENOSYS:        // Function not implemented
+    case ENOTSUP:       // Operation not supported
+    case EAFNOSUPPORT:  // Address family not supported
+#if !defined(_WIN32)
+    case EPFNOSUPPORT:  // Protocol family not supported
+#endif
+    case EPROTONOSUPPORT:  // Protocol not supported
+#if !defined(_WIN32) && !defined(__HAIKU__)
+    case ESOCKTNOSUPPORT:  // Socket type not supported
+#endif
+    case EXDEV:  // Improper link
+      code = absl::StatusCode::kUnimplemented;
+      break;
+    case EAGAIN:        // Resource temporarily unavailable
+    case ECONNREFUSED:  // Connection refused
+    case ECONNABORTED:  // Connection aborted
+    case ECONNRESET:    // Connection reset
+    case EINTR:         // Interrupted function call
+#if !defined(_WIN32)
+    case EHOSTDOWN:  // Host is down
+#endif
+    case EHOSTUNREACH:  // Host is unreachable
+    case ENETDOWN:      // Network is down
+    case ENETRESET:     // Connection aborted by network
+    case ENETUNREACH:   // Network unreachable
+    case ENOLCK:        // No locks available
+    case ENOLINK:       // Link has been severed
+#if !(defined(__APPLE__) || defined(__FreeBSD__) || defined(_WIN32) || \
+      defined(__HAIKU__))
+    case ENONET:  // Machine is not on the network
+#endif
+      code = absl::StatusCode::kUnavailable;
+      break;
+    case EDEADLK:  // Resource deadlock avoided
+#if !defined(_WIN32)
+    case ESTALE:  // Stale file handle
+#endif
+      code = absl::StatusCode::kAborted;
+      break;
+    case ECANCELED:  // Operation cancelled
+      code = absl::StatusCode::kCancelled;
+      break;
+    // NOTE: If you get any of the following (especially in a
+    // reproducible way) and can propose a better mapping,
+    // please email the owners about updating this mapping.
+    case EBADMSG:      // Bad message
+    case EIDRM:        // Identifier removed
+    case EINPROGRESS:  // Operation in progress
+    case EIO:          // I/O error
+    case ELOOP:        // Too many levels of symbolic links
+    case ENOEXEC:      // Exec format error
+    case ENOMSG:       // No message of the desired type
+    case EPROTO:       // Protocol error
+#if !defined(_WIN32) && !defined(__HAIKU__)
+    case EREMOTE:  // Object is remote
+#endif
+      code = absl::StatusCode::kUnknown;
+      break;
+    default: {
+      code = absl::StatusCode::kUnknown;
+      break;
+    }
+  }
+  return code;
+}

+}  // namespace

+absl::Status IOError(const std::string& context, int err_number) {
+  auto code = ErrnoToCode(err_number);
+  return absl::Status(code, absl::StrCat(context, "; ", strerror(err_number)));
+}

 // 128KB of copy buffer
 constexpr size_t kPosixCopyFileBufferSize = 128 * 1024;
@@ -45,22 +202,22 @@ constexpr size_t kPosixCopyFileBufferSize = 128 * 1024;
 // pread() based random-access
 class PosixRandomAccessFile : public RandomAccessFile {
  private:
-  string filename_;
+  std::string filename_;
   int fd_;

  public:
-  PosixRandomAccessFile(const string& fname, int fd)
+  PosixRandomAccessFile(const std::string& fname, int fd)
       : filename_(fname), fd_(fd) {}
   ~PosixRandomAccessFile() override { close(fd_); }

-  Status Name(absl::string_view* result) const override {
+  absl::Status Name(absl::string_view* result) const override {
     *result = filename_;
-    return Status::OK();
+    return absl::OkStatus();
   }

-  Status Read(uint64 offset, size_t n, absl::string_view* result,
+  absl::Status Read(uint64_t offset, size_t n, absl::string_view* result,
               char* scratch) const override {
-    Status s;
+    absl::Status s;
     char* dst = scratch;
     while (n > 0 && s.ok()) {
       // Some platforms, notably macs, throw EINVAL if pread is asked to read
@@ -78,7 +235,7 @@ class PosixRandomAccessFile : public RandomAccessFile {
         n -= r;
         offset += r;
       } else if (r == 0) {
-        s = Status(error::OUT_OF_RANGE, "Read less bytes than requested");
+        s = absl::OutOfRangeError("Read less bytes than requested");
       } else if (errno == EINTR || errno == EAGAIN) {
         // Retry
       } else {
@@ -92,11 +249,11 @@ class PosixRandomAccessFile : public RandomAccessFile {

 class PosixWritableFile : public WritableFile {
  private:
-  string filename_;
+  std::string filename_;
   FILE* file_;

  public:
-  PosixWritableFile(const string& fname, FILE* f)
+  PosixWritableFile(const std::string& fname, FILE* f)
       : filename_(fname), file_(f) {}

   ~PosixWritableFile() override {
@@ -106,19 +263,19 @@ class PosixWritableFile : public WritableFile {
     }
   }

-  Status Append(absl::string_view data) override {
+  absl::Status Append(absl::string_view data) override {
     size_t r = fwrite(data.data(), 1, data.size(), file_);
     if (r != data.size()) {
       return IOError(filename_, errno);
     }
-    return Status::OK();
+    return absl::OkStatus();
   }

-  Status Close() override {
+  absl::Status Close() override {
     if (file_ == nullptr) {
       return IOError(filename_, EBADF);
     }
-    Status result;
+    absl::Status result;
     if (fclose(file_) != 0) {
       result = IOError(filename_, errno);
     }
@@ -126,28 +283,28 @@ class PosixWritableFile : public WritableFile {
     return result;
   }

-  Status Flush() override {
+  absl::Status Flush() override {
     if (fflush(file_) != 0) {
       return IOError(filename_, errno);
     }
-    return Status::OK();
+    return absl::OkStatus();
   }

-  Status Name(absl::string_view* result) const override {
+  absl::Status Name(absl::string_view* result) const override {
     *result = filename_;
-    return Status::OK();
+    return absl::OkStatus();
   }

-  Status Sync() override {
-    Status s;
+  absl::Status Sync() override {
+    absl::Status s;
     if (fflush(file_) != 0) {
       s = IOError(filename_, errno);
     }
     return s;
   }

-  Status Tell(int64* position) override {
-    Status s;
+  absl::Status Tell(int64_t* position) override {
+    absl::Status s;
     *position = ftell(file_);

     if (*position == -1) {
@@ -160,23 +317,23 @@ class PosixWritableFile : public WritableFile {

 class PosixReadOnlyMemoryRegion : public ReadOnlyMemoryRegion {
  public:
-  PosixReadOnlyMemoryRegion(const void* address, uint64 length)
+  PosixReadOnlyMemoryRegion(const void* address, uint64_t length)
       : address_(address), length_(length) {}
   ~PosixReadOnlyMemoryRegion() override {
     munmap(const_cast<void*>(address_), length_);
   }
   const void* data() override { return address_; }
-  uint64 length() override { return length_; }
+  uint64_t length() override { return length_; }

  private:
   const void* const address_;
-  const uint64 length_;
+  const uint64_t length_;
 };

-Status PosixFileSystem::NewRandomAccessFile(
-    const string& fname, std::unique_ptr<RandomAccessFile>* result) {
-  string translated_fname = TranslateName(fname);
-  Status s;
+absl::Status PosixFileSystem::NewRandomAccessFile(
+    const std::string& fname, std::unique_ptr<RandomAccessFile>* result) {
+  std::string translated_fname = TranslateName(fname);
+  absl::Status s;
   int fd = open(translated_fname.c_str(), O_RDONLY);
   if (fd < 0) {
     s = IOError(fname, errno);
@@ -186,10 +343,10 @@ Status PosixFileSystem::NewRandomAccessFile(
   return s;
 }

-Status PosixFileSystem::NewWritableFile(const string& fname,
+absl::Status PosixFileSystem::NewWritableFile(const std::string& fname,
                                         std::unique_ptr<WritableFile>* result) {
-  string translated_fname = TranslateName(fname);
-  Status s;
+  std::string translated_fname = TranslateName(fname);
+  absl::Status s;
   FILE* f = fopen(translated_fname.c_str(), "w");
   if (f == nullptr) {
     s = IOError(fname, errno);
@@ -199,10 +356,10 @@ Status PosixFileSystem::NewWritableFile(const string& fname,
   return s;
 }

-Status PosixFileSystem::NewAppendableFile(
-    const string& fname, std::unique_ptr<WritableFile>* result) {
-  string translated_fname = TranslateName(fname);
-  Status s;
+absl::Status PosixFileSystem::NewAppendableFile(
+    const std::string& fname, std::unique_ptr<WritableFile>* result) {
+  std::string translated_fname = TranslateName(fname);
+  absl::Status s;
   FILE* f = fopen(translated_fname.c_str(), "a");
   if (f == nullptr) {
     s = IOError(fname, errno);
@@ -212,10 +369,10 @@ Status PosixFileSystem::NewAppendableFile(
   return s;
 }

-Status PosixFileSystem::NewReadOnlyMemoryRegionFromFile(
-    const string& fname, std::unique_ptr<ReadOnlyMemoryRegion>* result) {
-  string translated_fname = TranslateName(fname);
-  Status s = Status::OK();
+absl::Status PosixFileSystem::NewReadOnlyMemoryRegionFromFile(
+    const std::string& fname, std::unique_ptr<ReadOnlyMemoryRegion>* result) {
+  std::string translated_fname = TranslateName(fname);
+  absl::Status s = absl::OkStatus();
   int fd = open(translated_fname.c_str(), O_RDONLY);
   if (fd < 0) {
     s = IOError(fname, errno);
@@ -234,16 +391,16 @@ Status PosixFileSystem::NewReadOnlyMemoryRegionFromFile(
   return s;
 }

-Status PosixFileSystem::FileExists(const string& fname) {
+absl::Status PosixFileSystem::FileExists(const std::string& fname) {
   if (access(TranslateName(fname).c_str(), F_OK) == 0) {
-    return Status::OK();
+    return absl::OkStatus();
   }
-  return errors::NotFound(fname, " not found");
+  return absl::NotFoundError(absl::StrCat(fname, " not found"));
 }

-Status PosixFileSystem::GetChildren(const string& dir,
-                                    std::vector<string>* result) {
-  string translated_dir = TranslateName(dir);
+absl::Status PosixFileSystem::GetChildren(const std::string& dir,
+                                    std::vector<std::string>* result) {
+  std::string translated_dir = TranslateName(dir);
   result->clear();
   DIR* d = opendir(translated_dir.c_str());
   if (d == nullptr) {
@@ -257,43 +414,43 @@ Status PosixFileSystem::GetChildren(const string& dir,
     }
   }
   closedir(d);
-  return Status::OK();
+  return absl::OkStatus();
 }

-Status PosixFileSystem::GetMatchingPaths(const string& pattern,
-                                         std::vector<string>* results) {
-  return internal::GetMatchingPaths(this, Env::Default(), pattern, results);
+absl::Status PosixFileSystem::GetMatchingPaths(const std::string& pattern,
+                                         std::vector<std::string>* results) {
+  return internal::GetMatchingPaths(this, pattern, results);
 }

-Status PosixFileSystem::DeleteFile(const string& fname) {
-  Status result;
+absl::Status PosixFileSystem::DeleteFile(const std::string& fname) {
+  absl::Status result;
   if (unlink(TranslateName(fname).c_str()) != 0) {
     result = IOError(fname, errno);
   }
   return result;
 }

-Status PosixFileSystem::CreateDir(const string& name) {
-  string translated = TranslateName(name);
+absl::Status PosixFileSystem::CreateDir(const std::string& name) {
+  std::string translated = TranslateName(name);
   if (translated.empty()) {
-    return errors::AlreadyExists(name);
+    return absl::AlreadyExistsError(name);
   }
   if (mkdir(translated.c_str(), 0755) != 0) {
     return IOError(name, errno);
   }
-  return Status::OK();
+  return absl::OkStatus();
 }

-Status PosixFileSystem::DeleteDir(const string& name) {
-  Status result;
+absl::Status PosixFileSystem::DeleteDir(const std::string& name) {
+  absl::Status result;
   if (rmdir(TranslateName(name).c_str()) != 0) {
     result = IOError(name, errno);
   }
   return result;
 }

-Status PosixFileSystem::GetFileSize(const string& fname, uint64* size) {
-  Status s;
+absl::Status PosixFileSystem::GetFileSize(const std::string& fname, uint64_t* size) {
+  absl::Status s;
   struct stat sbuf;
   if (stat(TranslateName(fname).c_str(), &sbuf) != 0) {
     *size = 0;
@@ -304,8 +461,8 @@ Status PosixFileSystem::GetFileSize(const string& fname, uint64* size) {
   return s;
 }

-Status PosixFileSystem::Stat(const string& fname, FileStatistics* stats) {
-  Status s;
+absl::Status PosixFileSystem::Stat(const std::string& fname, FileStatistics* stats) {
+  absl::Status s;
   struct stat sbuf;
   if (stat(TranslateName(fname).c_str(), &sbuf) != 0) {
     s = IOError(fname, errno);
@@ -317,16 +474,16 @@ Status PosixFileSystem::Stat(const string& fname, FileStatistics* stats) {
   return s;
 }

-Status PosixFileSystem::RenameFile(const string& src, const string& target) {
-  Status result;
+absl::Status PosixFileSystem::RenameFile(const std::string& src, const std::string& target) {
+  absl::Status result;
   if (rename(TranslateName(src).c_str(), TranslateName(target).c_str()) != 0) {
     result = IOError(src, errno);
   }
   return result;
 }

-Status PosixFileSystem::CopyFile(const string& src, const string& target) {
-  string translated_src = TranslateName(src);
+absl::Status PosixFileSystem::CopyFile(const std::string& src, const std::string& target) {
+  std::string translated_src = TranslateName(src);
   struct stat sbuf;
   if (stat(translated_src.c_str(), &sbuf) != 0) {
     return IOError(src, errno);
@@ -335,7 +492,7 @@ Status PosixFileSystem::CopyFile(const string& src, const string& target) {
   if (src_fd < 0) {
     return IOError(src, errno);
   }
-  string translated_target = TranslateName(target);
+  std::string translated_target = TranslateName(target);
   // O_WRONLY | O_CREAT | O_TRUNC:
   //   Open file for write and if file does not exist, create the file.
   //   If file exists, truncate its size to 0.
@@ -351,12 +508,12 @@ Status PosixFileSystem::CopyFile(const string& src, const string& target) {
   off_t offset = 0;
   std::unique_ptr<char[]> buffer(new char[kPosixCopyFileBufferSize]);
   while (offset < sbuf.st_size) {
-    // Use uint64 for safe compare SSIZE_MAX
-    uint64 chunk = sbuf.st_size - offset;
+    // Use uint64_t for safe compare SSIZE_MAX
+    uint64_t chunk = sbuf.st_size - offset;
     if (chunk > SSIZE_MAX) {
       chunk = SSIZE_MAX;
     }
-#if defined(__linux__) && !defined(__ANDROID__)
+#if OS_LINUX && !OS_ANDROID
     rc = sendfile(target_fd, src_fd, &offset, static_cast<size_t>(chunk));
 #else
     if (chunk > kPosixCopyFileBufferSize) {
@@ -374,22 +531,22 @@ Status PosixFileSystem::CopyFile(const string& src, const string& target) {
     }
   }

-  Status result = Status::OK();
+  absl::Status result = absl::OkStatus();
   if (rc < 0) {
     result = IOError(target, errno);
   }

   // Keep the error code
   rc = close(target_fd);
-  if (rc < 0 && result == Status::OK()) {
+  if (rc < 0 && result == absl::OkStatus()) {
     result = IOError(target, errno);
   }
   rc = close(src_fd);
-  if (rc < 0 && result == Status::OK()) {
+  if (rc < 0 && result == absl::OkStatus()) {
     result = IOError(target, errno);
   }

   return result;
 }

-
+}  // namespace gtl
diff --git a/gtl/posix_file_system.h b/gtl/posix_file_system.h
index 8378ddd..7553f16 100644
--- a/gtl/posix_file_system.h
+++ b/gtl/posix_file_system.h
@@ -16,64 +16,67 @@ limitations under the License.
 #ifndef GTL_POSIX_FILE_SYSTEM_H_
 #define GTL_POSIX_FILE_SYSTEM_H_

-#include "gtl/env.h"
-#include "gtl/path.h"
+#include <memory>
+#include <string>
+#include <vector>

+#include "third_party/absl/status/status.h"
+#include "gtl/file_system.h"
+#include "gtl/path.h"

+namespace gtl {

 class PosixFileSystem : public FileSystem {
  public:
-  PosixFileSystem() {}
+  PosixFileSystem() = default;

-  ~PosixFileSystem() {}
+  ~PosixFileSystem() override = default;

-  Status NewRandomAccessFile(
-      const string& filename,
+  absl::Status NewRandomAccessFile(
+      const std::string& filename,
       std::unique_ptr<RandomAccessFile>* result) override;

-  Status NewWritableFile(const string& fname,
+  absl::Status NewWritableFile(const std::string& fname,
                          std::unique_ptr<WritableFile>* result) override;

-  Status NewAppendableFile(const string& fname,
+  absl::Status NewAppendableFile(const std::string& fname,
                            std::unique_ptr<WritableFile>* result) override;

-  Status NewReadOnlyMemoryRegionFromFile(
-      const string& filename,
+  absl::Status NewReadOnlyMemoryRegionFromFile(
+      const std::string& filename,
       std::unique_ptr<ReadOnlyMemoryRegion>* result) override;

-  Status FileExists(const string& fname) override;
+  absl::Status FileExists(const std::string& fname) override;

-  Status GetChildren(const string& dir, std::vector<string>* result) override;
+  absl::Status GetChildren(const std::string& dir, std::vector<std::string>* result) override;

-  Status Stat(const string& fname, FileStatistics* stats) override;
+  absl::Status Stat(const std::string& fname, FileStatistics* stats) override;

-  Status GetMatchingPaths(const string& pattern,
-                          std::vector<string>* results) override;
+  absl::Status GetMatchingPaths(const std::string& pattern,
+                          std::vector<std::string>* results) override;

-  Status DeleteFile(const string& fname) override;
+  absl::Status DeleteFile(const std::string& fname) override;

-  Status CreateDir(const string& name) override;
+  absl::Status CreateDir(const std::string& name) override;

-  Status DeleteDir(const string& name) override;
+  absl::Status DeleteDir(const std::string& name) override;

-  Status GetFileSize(const string& fname, uint64* size) override;
+  absl::Status GetFileSize(const std::string& fname, uint64_t* size) override;

-  Status RenameFile(const string& src, const string& target) override;
+  absl::Status RenameFile(const std::string& src, const std::string& target) override;

-  Status CopyFile(const string& src, const string& target) override;
+  absl::Status CopyFile(const std::string& src, const std::string& target) override;
 };

-Status IOError(const string& context, int err_number);
-
 class LocalPosixFileSystem : public PosixFileSystem {
  public:
-  string TranslateName(const string& name) const override {
+  std::string TranslateName(const std::string& name) const override {
     absl::string_view scheme, host, path;
-    io::ParseURI(name, &scheme, &host, &path);
-    return string(path);
+    ParseURI(name, &scheme, &host, &path);
+    return std::string(path);
   }
 };

-
+}  // namespace gtl

 #endif  // GTL_POSIX_FILE_SYSTEM_H_
